#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
/*#include <cairo.h>
#include <gtk/gtk.h>
//#include <string.h>
//#include <stlib.h>*/
#define dulj 106
#define WIN 24000	
#define intmax 32000
#define pocetnipotez 15
#define cutoff 25
#define vrh_off 5

//#define 

// definicija polja 
/*typedef struct ind obj;
struct ind {
	int ind;
	obj * s[6];
};*/
typedef struct poljevektor vct;
struct poljevektor {
	int s[7][2];
};

typedef struct poljevektor boardvektor[ dulj+1 ];

boardvektor bp={{{{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0}}},				//0
		{{{243,20},{250,0},{224,18},{237,35},{262,35},{274,18},{-1,0}}},	//1
		{{{211,45},{224,18},{237,35},{229,59},{203,59},{191,43},{-1,0}}},	//2
		{{{243,55},{237,35},{229,59},{237,70},{262,70},{270,59},{262,35}}},	//3
		{{{277,45},{274,18},{262,35},{270,59},{295,59},{308,43},{-1,0}}},	//4
		{{{179,70},{191,43},{158,66},{170,83},{195,83},{203,59},{-1,0}}},	//5
		{{{211,80},{237,70},{229,59},{203,59},{195,83},{203,94},{229,94}}},	//6
		{{{243,95},{262,70},{237,70},{229,94},{237,105},{262,105},{270,94}}},	//7
		{{{277,80},{295,59},{270,59},{262,70},{270,94},{295,94},{303,83}}},	//8
		{{{310,70},{308,43},{295,59},{303,83},{329,83},{342,68},{-1,0}}},	//9
		{{{138,92},{158,66},{125,91},{137,107},{162,107},{171,83},{-1,0}}},	//10
		{{{175,105},{196,83},{170,83},{162,107},{171,118},{195,118},{203,94}}},	//11
		{{{207,115},{229,94},{203,94},{195,118},{204,129},{228,129},{237,105}}},	//12
		{{{239,125},{262,105},{237,105},{229,129},{237,140},{262,140},{270,129}}},	//13
		{{{273,115},{296,94},{270,94},{262,105},{270,129},{296,129},{304,118}}},	//14
		{{{306,105},{329,83},{303,83},{295,94},{303,118},{329,118},{337,107}}},	//15
		{{{339,95},{374,91},{341,68},{329,83},{337,107},{362,107},{-1,0}}},	//16
		{{{103,120},{125,91},{91,115},{104,131},{129,132},{137,107},{-1,0}}},	//17
		{{{138,127},{162,107},{137,107},{129,132},{137,142},{162,142},{170,118}}},	//18
		{{{175,140},{196,118},{170,118},{162,142},{170,153},{196,153},{203,129}}},	//19
		{{{207,150},{229,129},{204,129},{196,153},{204,164},{229,164},{237,142}}},	//20
		{{{239,160},{262,140},{237,140},{229,164},{237,175},{262,175},{270,164}}},	//21
		{{{273,150},{295,129},{270,129},{262,140},{270,164},{295,164},{304,153}}},	//22
		{{{306,140},{329,118},{305,118},{295,129},{305,153},{329,153},{337,142}}},	//23
		{{{339,130},{362,107},{337,107},{329,118},{337,142},{362,142},{370,132}}},	//24
		{{{372,120},{374,91},{362,107},{370,132},{395,132},{408,115},{-1,0}}},	//25
		{{{68,145},{91,115},{58,139},{71,156},{96,156},{104,132},{-1,0}}},	//26
		{{{103,155},{129,132},{104,132},{96,156},{104,167},{129,167},{137,142}}},	//27
		{{{138,162},{162,142},{137,142},{129,167},{137,177},{162,177},{170,153}}},	//28
		{{{175,175},{196,153},{170,153},{162,177},{170,188},{195,188},{203,163}}},	//29
		{{{207,185},{229,164},{203,164},{196,188},{203,199},{229,199},{237,175}}},	//30
		{{{239,195},{262,175},{237,175},{229,199},{237,210},{262,210},{270,199}}},	//31
		{{{273,185},{296,164},{270,164},{262,175},{270,199},{295,199},{303,188}}},	//32
		{{{306,175},{329,153},{303,153},{295,164},{303,188},{329,188},{337,177}}},	//33
		{{{339,165},{362,142},{337,142},{329,153},{337,177},{362,177},{370,167}}},	//34
		{{{372,155},{395,132},{370,132},{362,142},{370,167},{395,167},{403,156}}},	//35
		{{{402,140},{408,115},{395,132},{403,156},{429,156},{441,139},{-1,0}}},	//36
		{{{40,165},{58,139},{33,157},{43,187},{62,180},{70,156},{-1,0}}},	//37
		{{{70,175},{96,156},{70,156},{63,180},{83,197},{96,191},{104,167}}},	//38
		{{{107,185},{129,167},{104,167},{96,191},{116,206},{129,202},{137,177}}},	//39
		{{{138,197},{162,177},{137,177},{129,201},{149,217},{162,212},{170,188}}},	//40
		{{{175,210},{195,188},{170,188},{162,212},{183,227},{196,223},{204,199}}},	//41
		{{{207,220},{229,199},{203,199},{196,223},{216,238},{229,234},{237,210}}},	//42
		{{{239,230},{262,210},{237,210},{229,234},{249,249},{270,234},{-1,0}}},	//43
		{{{273,220},{295,199},{270,199},{262,210},{270,234},{283,238},{303,223}}},	//44
		{{{306,210},{329,188},{304,188},{295,199},{303,223},{316,227},{336,212}}},	//45
		{{{339,200},{362,177},{337,177},{329,188},{337,212},{349,217},{370,202}}},	//46
		{{{372,190},{395,167},{370,167},{362,177},{370,202},{383,206},{403,191}}},	//47
		{{{402,175},{428,156},{403,156},{395,167},{403,191},{416,195},{436,180}}},	//48
		{{{435,160},{441,139},{428,156},{436,180},{456,187},{466,157},{-1,0}}},	//49
		{{{53,204},{63,180},{43,187},{55,225},{75,219},{83,195},{-1,0}}},	//50
		{{{84,213},{96,191},{83,195},{75,219},{96,234},{108,230},{116,206}}},	//51
		{{{117,225},{129,201},{116,206},{109,230},{129,245},{142,241},{149,216}}},	//52
		{{{149,237},{162,212},{149,216},{142,241},{162,256},{175,251},{183,228}}},	//53
		{{{181,249},{196,223},{183,228},{175,251},{195,266},{208,262},{216,238}}},	//54
		{{{222,257},{229,234},{216,238},{208,262},{229,277},{249,262},{249,249}}},	//55
		{{{263,257},{270,234},{249,249},{249,263},{270,277},{290,262},{283,239}}},	//56
		{{{296,246},{303,223},{283,238},{290,262},{303,267},{324,251},{316,228}}},	//57
		{{{329,235},{336,212},{316,228},{324,251},{337,256},{357,240},{349,217}}},	//58
		{{{362,223},{370,201},{349,217},{357,240},{370,245},{390,230},{383,206}}},	//59
		{{{398,211},{403,191},{383,206},{391,230},{403,234},{424,219},{416,195}}},	//60
		{{{424,200},{437,180},{416,195},{424,219},{443,226},{456,187},{-1,0}}},	//61
		{{{66,243},{75,219},{55,226},{68,265},{88,258},{96,234},{-1,0}}},	//62
		{{{98,251},{108,230},{96,234},{88,258},{108,273},{121,269},{129,245}}},	//63
		{{{130,260},{142,240},{129,245},{121,269},{142,284},{155,279},{162,256}}},	//64
		{{{162,269},{175,251},{162,256},{155,280},{175,295},{188,290},{195,267}}},	//65
		{{{202,287},{208,262},{195,266},{188,290},{208,306},{229,290},{229,278}}},	//66
		{{{239,287},{249,262},{229,278},{229,290},{249,306},{270,290},{270,278}}},	//67
		{{{284,287},{290,263},{270,278},{270,290},{291,306},{311,290},{303,267}}},	//68
		{{{316,275},{324,251},{303,267},{311,290},{324,295},{344,280},{337,256}}},	//69
		{{{348,263},{357,241},{337,256},{344,280},{357,284},{378,269},{370,245}}},	//70
		{{{380,252},{390,230},{370,245},{378,269},{390,273},{411,258},{403,234}}},	//71
		{{{411,240},{424,219},{403,234},{411,258},{431,265},{444,225},{-1,0}}},	//72
		{{{79,282},{88,258},{68,265},{81,304},{100,297},{108,274},{-1,0}}},	//73
		{{{112,289},{121,269},{108,275},{101,297},{121,313},{134,308},{142,284}}},	//74
		{{{145,298},{155,280},{142,284},{134,308},{154,323},{167,319},{175,295}}},	//75
		{{{181,315},{188,291},{175,295},{167,319},{188,334},{208,319},{208,306}}},	//76
		{{{222,315},{229,291},{208,306},{208,319},{229,334},{249,319},{249,306}}},	//77
		{{{264,315},{270,291},{249,306},{249,319},{270,334},{291,319},{291,306}}},	//78
		{{{305,315},{311,292},{291,306},{291,319},{311,334},{332,319},{324,295}}},	//79
		{{{336,303},{344,280},{324,295},{332,319},{345,324},{365,308},{357,284}}},	//80
		{{{368,291},{378,269},{357,285},{365,308},{378,313},{398,297},{391,273}}},	//81
		{{{399,280},{411,258},{391,273},{398,297},{418,304},{431,265},{-1,0}}},	//82
		{{{92,321},{81,304},{93,344},{113,336},{121,313},{100,297},{-1,0}}},	//83
		{{{126,330},{134,308},{121,313},{113,337},{134,352},{147,347},{154,323}}},	//84
		{{{160,340},{167,319},{154,323},{147,347},{165,362},{188,347},{188,334}}},	//85
		{{{201,340},{208,319},{188,334},{188,347},{208,362},{229,347},{229,334}}},	//86
		{{{243,340},{249,319},{229,334},{229,347},{249,362},{270,347},{270,334}}},	//87
		{{{284,340},{290,319},{270,334},{270,347},{291,362},{311,347},{311,334}}},	//88
		{{{325,340},{332,319},{311,334},{311,347},{332,362},{352,347},{344,324}}},	//89
		{{{356,330},{365,308},{344,323},{352,347},{365,352},{385,337},{378,314}}},	//90
		{{{387,320},{398,297},{378,313},{385,337},{405,343},{418,306},{-1,0}}},	//91
		{{{105,360},{113,336},{94,344},{106,383},{126,375},{134,351},{-1,0}}},	//92
		{{{140,370},{147,347},{134,352},{126,375},{146,390},{167,376},{167,363}}},	//93
		{{{181,370},{188,347},{167,362},{167,375},{188,390},{208,376},{208,363}}},	//94
		{{{222,370},{229,347},{208,362},{208,375},{229,390},{249,376},{249,363}}},	//95
		{{{263,370},{270,347},{249,362},{249,375},{270,390},{290,376},{290,363}}},	//96
		{{{304,370},{311,347},{291,362},{291,374},{311,390},{332,376},{332,363}}},	//97
		{{{342,370},{352,347},{332,362},{332,374},{352,390},{373,376},{365,352}}},	//98
		{{{375,360},{385,336},{365,352},{373,375},{393,382},{405,343},{-1,0}}},	//99
		{{{115,400},{126,375},{106,382},{114,412},{147,412},{147,391},{-1,0}}},	//100
		{{{155,400},{167,375},{147,391},{147,412},{188,412},{188,391},{-1,0}}},	//101
		{{{196,400},{208,375},{188,391},{188,412},{229,412},{229,391},{-1,0}}},	//102
		{{{235,400},{249,375},{229,391},{229,412},{270,412},{270,391},{-1,0}}},	//103
		{{{279,400},{294,375},{270,391},{270,412},{311,412},{311,391},{-1,0}}},	//104
		{{{320,400},{332,375},{311,391},{311,412},{352,412},{352,391},{-1,0}}},	//105
		{{{358,400},{373,375},{352,391},{352,412},{383,412},{393,383},{-1,0}}},	//106
	};

/*static void do_drawing(cairo_t *cr);
void crtajpolje(cairo_t *cr, double scale, int x, int y, int ind, double rgb[3], int which, int str);*/


typedef struct polje obj;
struct polje {
	int ind;
	int s[6];
	int igrac;
	int protivnik;
	int boja;
};

typedef struct polje ploca[ dulj+1 ];

ploca b={{0,{0,0,0,0,0,0},0,0,0},
	 {1,{0,0,2,3,4,0},0,0,1},
	 {2,{0,0,5,6,3,1},0,0,6},
	 {3,{1,2,6,7,8,4},0,0,0},
	 {4,{0,1,3,8,9,0},0,0,10},
	 {5,{0,0,10,11,6,2},0,0,6},
	 {6,{2,5,11,12,7,3},0,0,0},
	 {7,{3,6,12,13,14,8},0,0,0},
	 {8,{4,3,7,14,15,9},0,0,0},
	 {9,{0,4,8,15,16,0},0,0,10},
	 {10,{0,0,17,18,11,5},0,0,6},
	 {11,{5,10,18,19,12,6},0,0,0},
	 {12,{6,11,19,20,13,7},0,0,0},
	 {13,{7,12,20,21,22,14},0,0,0},
	 {14,{8,7,13,22,23,15},0,0,0},
	 {15,{9,8,14,23,24,16},0,0,0},
	 {16,{0,9,15,24,25,0},0,0,10},
	 {17,{0,0,26,27,18,10},0,0,6},
	 {18,{10,17,27,28,19,11},0,0,0},
	 {19,{11,18,28,29,20,12},0,0,0},
	 {20,{12,19,29,30,21,13},0,0,0},
	 {21,{13,20,30,31,32,22},0,0,0},
	 {22,{14,13,21,32,33,23},0,0,0},
	 {23,{15,14,22,33,34,24},0,0,0},
	 {24,{16,15,23,34,35,25},0,0,0},
	 {25,{0,16,24,35,36,0},0,0,10},
	 {26,{0,0,37,38,27,17},0,0,6},
	 {27,{17,26,38,39,28,18},0,0,0},
	 {28,{18,27,39,40,29,19},0,0,0},
	 {29,{19,28,40,41,30,20},0,0,0},
	 {30,{20,29,41,42,31,21},0,0,0},
	 {31,{21,30,42,43,44,32},0,0,0},
	 {32,{22,21,31,44,45,33},0,0,0},
	 {33,{23,22,32,45,46,34},0,0,0},
	 {34,{24,23,33,46,47,35},0,0,0},
	 {35,{25,24,34,47,48,36},0,0,0},
	 {36,{0,25,35,48,49,0},0,0,10},
	 {37,{0,0,0,50,38,26},0,0,2},
	 {38,{26,37,50,51,39,27},0,0,0},
	 {39,{27,38,51,52,40,28},0,0,0},
	 {40,{28,39,52,53,41,29},0,0,0},
	 {41,{29,40,53,54,42,30},0,0,0},
	 {42,{30,41,54,55,43,31},0,0,0},
	 {43,{31,42,55,56,44,0},0,0,0},
	 {44,{32,31,43,56,57,45},0,0,0},
	 {45,{33,32,44,57,58,46},0,0,0},
	 {46,{34,33,45,58,59,47},0,0,0},
	 {47,{35,34,46,59,60,48},0,0,0},
	 {48,{36,35,47,60,61,49},0,0,0},
	 {49,{0,36,48,61,0,0},0,0,5},
	 {50,{37,0,0,62,51,38},0,0,7},
	 {51,{38,50,62,63,52,39},0,0,0},
	 {52,{39,51,63,64,53,40},0,0,0},
	 {53,{40,52,64,65,54,41},0,0,0},
	 {54,{41,53,65,66,55,42},0,0,0},
	 {55,{42,54,66,67,56,43},0,0,0},
	 {56,{43,55,67,68,57,44},0,0,0},
	 {57,{44,56,68,69,58,45},0,0,0},
	 {58,{45,57,69,70,59,46},0,0,0},
	 {59,{46,58,70,71,60,47},0,0,0},
	 {60,{47,59,71,72,61,48},0,0,0},
	 {61,{48,60,72,0,0,49},0,0,9},
	 {62,{50,0,0,73,63,51},0,0,7},
	 {63,{51,62,73,74,64,52},0,0,0},
	 {64,{52,63,74,75,65,53},0,0,0},
	 {65,{53,64,75,76,66,54},0,0,0},
	 {66,{54,65,76,77,67,55},0,0,0},
	 {67,{55,66,77,78,68,56},0,0,0},
	 {68,{56,67,78,79,69,57},0,0,0},
	 {69,{57,68,79,80,70,58},0,0,0},
	 {70,{58,69,80,81,71,59},0,0,0},
	 {71,{59,70,81,82,72,60},0,0,0},
	 {72,{60,71,82,0,0,61},0,0,9},
	 {73,{62,0,0,83,74,63},0,0,7},
	 {74,{63,73,83,84,75,64},0,0,0},
	 {75,{64,74,84,85,76,65},0,0,0},
	 {76,{65,75,85,86,77,66},0,0,0},
	 {77,{66,76,86,87,78,67},0,0,0},
	 {78,{67,77,87,88,79,68},0,0,0},
	 {79,{68,78,88,89,80,69},0,0,0},
	 {80,{69,79,89,90,81,70},0,0,0},
	 {81,{70,80,90,91,82,71},0,0,0},
	 {82,{71,81,91,0,0,72},0,0,9},
	 {83,{73,0,0,92,84,74},0,0,7},
	 {84,{74,83,92,93,85,75},0,0,0},
	 {85,{75,84,93,94,86,76},0,0,0},
	 {86,{76,85,94,95,87,77},0,0,0},
	 {87,{77,86,95,96,88,78},0,0,0},
	 {88,{78,87,96,97,89,79},0,0,0},
	 {89,{79,88,97,98,90,80},0,0,0},
	 {90,{80,89,98,99,91,81},0,0,0},
	 {91,{81,90,99,0,0,82},0,0,9},
	 {92,{83,0,0,100,93,84},0,0,7},
	 {93,{84,92,100,101,94,85},0,0,0},
	 {94,{85,93,101,102,95,86},0,0,0},
	 {95,{86,94,102,103,96,87},0,0,0},
	 {96,{87,95,103,104,97,88},0,0,0},
	 {97,{88,96,104,105,98,89},0,0,0},
	 {98,{89,97,105,106,99,90},0,0,0},
	 {99,{90,98,106,0,0,91},0,0,9},
	 {100,{92,0,0,0,101,93},0,0,3},
	 {101,{93,100,0,0,102,94},0,0,8},
	 {102,{94,101,0,0,103,95},0,0,8},
	 {103,{95,102,0,0,104,96},0,0,8},
	 {104,{96,103,0,0,105,97},0,0,8},
	 {105,{97,104,0,0,106,98},0,0,8},
	 {106,{98,105,0,0,0,99},0,0,4}
	};

typedef struct forspolje {
	int	s[ 6 ];
	int	kl[ 12 ];
	int	bl[ 12 ];	
} forspolje;

typedef struct forspolje forsboard[ dulj + 1 ];

forsboard fb = {{ {0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0} },	//0
		{ {0,0,6,8,0,0}, {0,0,2,3,4,0,0,2,3,4,0,0}, {0,0,0,7,0,0,0,0,7,0,0,0} },	//1
		{ {0,0,11,7,4,0}, {0,0,5,6,3,1,0,5,6,3,1,0}, {0,0,0,12,8,0,0,0,12,8,0,0} },	//2
		{ {0,5,12,14,9,0}, {1,2,6,7,8,4,2,6,7,8,4,1}, {0,0,11,13,15,0,0,11,13,15,0,0} },	//3
		{ {0,2,7,15,0,0}, {0,1,3,8,9,0,1,3,8,9,0,0}, {0,0,6,14,0,0,0,6,14,0,0,0} },	//4
		{ {0,0,18,12,3,0}, {0,0,10,11,6,2,0,10,11,6,2,0}, {0,0,0,19,7,0,0,0,19,7,0,0} },	//5
		{ {10,19,13,8,1,0}, {5,11,12,7,3,2,11,12,7,3,2,5}, {0,18,20,14,4,0,18,20,14,4,0,0} },	//6
		{ {2,11,20,22,15,4}, {3,6,12,13,14,8,6,12,13,14,8,3}, {1,5,19,21,23,9,5,19,21,23,9,1} },	//7
		{ {1,6,13,23,16,0}, {4,3,7,14,15,9,3,7,14,15,9,4}, {0,2,12,22,24,0,2,12,22,24,0,0} },	//8
		{ {0,3,14,24,0,0}, {0,4,8,15,16,0,4,8,15,16,0,0}, {0,0,7,23,0,0,0,7,23,0,0,0} },	//9
		{ {0,0,27,19,6,0}, {0,0,17,18,11,5,0,17,18,11,5,0}, {0,0,0,28,12,0,0,0,28,12,0,0} },	//10
		{ {17,28,20,7,2,0}, {10,18,19,12,6,5,18,19,12,6,5,10}, {0,27,29,13,3,0,27,29,13,3,0,0} },	//11
		{ {5,18,29,21,14,3}, {6,11,19,20,13,7,11,19,20,13,7,6}, {2,10,28,30,22,8,10,28,30,22,8,2} },	//12
		{ {6,19,30,32,23,8}, {7,12,20,21,22,14,12,20,21,22,14,7}, {3,11,29,31,33,15,11,29,31,33,15,3} },	//13
		{ {3,12,21,33,24,9}, {8,7,13,22,23,15,7,13,22,23,15,8}, {4,6,20,32,34,16,6,20,32,34,16,4} },	//14
		{ {4,7,22,34,25,0}, {9,8,14,23,24,16,8,14,23,24,16,9}, {0,3,13,33,35,0,3,13,33,35,0,0} },	//15
		{ {0,8,23,35,0,0}, {0,9,15,24,25,0,9,15,24,25,0,0}, {0,0,14,34,0,0,0,14,34,0,0,0} },	//16
		{ {0,0,38,28,11,0}, {0,0,26,27,18,10,0,26,27,18,10,0}, {0,0,0,39,19,0,0,0,39,19,0,0} },	//17
		{ {26,39,29,12,5,0}, {17,27,28,19,11,10,27,28,19,11,10,17}, {0,38,40,20,6,0,38,40,20,6,0,0} },	//18
		{ {10,27,40,30,13,6}, {11,18,28,29,20,12,18,28,29,20,12,11}, {5,17,39,41,21,7,17,39,41,21,7,5} },	//19
		{ {11,28,41,31,22,7}, {12,19,29,30,21,13,19,29,30,21,13,12}, {6,18,40,42,32,14,18,40,42,32,14,6} },	//20
		{ {12,29,42,44,33,14}, {13,20,30,31,32,22,20,30,31,32,22,13}, {7,19,41,43,45,23,19,41,43,45,23,7} },	//21
		{ {7,20,31,45,34,15}, {14,13,21,32,33,23,13,21,32,33,23,14}, {8,12,30,44,46,24,12,30,44,46,24,8} },	//22
		{ {8,13,32,46,35,16}, {15,14,22,33,34,24,14,22,33,34,24,15}, {9,7,21,45,47,25,7,21,45,47,25,9} },	//23
		{ {9,14,33,47,36,0}, {16,15,23,34,35,25,15,23,34,35,25,16}, {0,8,22,46,48,0,8,22,46,48,0,0} },	//24
		{ {0,15,34,48,0,0}, {0,16,24,35,36,0,16,24,35,36,0,0}, {0,0,23,47,0,0,0,23,47,0,0,0} },	//25
		{ {0,0,50,39,18,0}, {0,0,37,38,27,17,0,37,38,27,17,0}, {0,0,0,51,28,0,0,0,51,28,0,0} },	//26
		{ {37,51,40,19,10,0}, {26,38,39,28,18,17,38,39,28,18,17,26}, {0,50,52,29,11,0,50,52,29,11,0,0} },	//27
		{ {17,38,52,41,20,11}, {18,27,39,40,29,19,27,39,40,29,19,18}, {10,26,51,53,30,12,26,51,53,30,12,10} },	//28
		{ {18,39,53,42,21,12}, {19,28,40,41,30,20,28,40,41,30,20,19}, {11,27,52,54,31,13,27,52,54,31,13,11} },	//29
		{ {19,40,54,43,32,13}, {20,29,41,42,31,21,29,41,42,31,21,20}, {12,28,53,55,44,22,28,53,55,44,22,12} },	//30
		{ {20,41,55,56,45,22}, {21,30,42,43,44,32,30,42,43,44,32,21}, {13,29,54,0,57,33,29,54,0,57,33,13} },	//31
		{ {13,30,43,57,46,23}, {22,21,31,44,45,33,21,31,44,45,33,22}, {14,20,42,56,58,34,20,42,56,58,34,14} },	//32
		{ {14,21,44,58,47,24}, {23,22,32,45,46,34,22,32,45,46,34,23}, {15,13,31,57,59,35,13,31,57,59,35,15} },	//33
		{ {15,22,45,59,48,25}, {24,23,33,46,47,35,23,33,46,47,35,24}, {16,14,32,58,60,36,14,32,58,60,36,16} },	//34
		{ {16,23,46,60,49,0}, {25,24,34,47,48,36,24,34,47,48,36,25}, {0,15,33,59,61,0,15,33,59,61,0,0} },	//35
		{ {0,24,47,61,0,0}, {0,25,35,48,49,0,25,35,48,49,0,0}, {0,0,34,60,0,0,0,34,60,0,0,0} },	//36
		{ {0,0,0,51,27,0}, {0,0,0,50,38,26,0,0,50,38,26,0}, {0,0,0,0,39,0,0,0,0,39,0,0} },	//37
		{ {0,62,52,28,17,0}, {37,50,51,39,27,26,50,51,39,27,26,37}, {0,0,63,40,18,0,0,63,40,18,0,0} },	//38
		{ {26,50,63,53,29,18}, {27,38,51,52,40,28,38,51,52,40,28,27}, {17,37,62,64,41,19,37,62,64,41,19,17} },	//39
		{ {27,51,64,54,30,19}, {28,39,52,53,41,29,39,52,53,41,29,28}, {18,38,63,65,42,20,38,63,65,42,20,18} },	//40
		{ {28,52,65,55,31,20}, {29,40,53,54,42,30,40,53,54,42,30,29}, {19,39,64,66,43,21,39,64,66,43,21,19} },	//41
		{ {29,53,66,56,44,21}, {30,41,54,55,43,31,41,54,55,43,31,30}, {20,40,65,67,0,32,40,65,67,0,32,20} },	//42
		{ {30,54,67,57,32,0}, {31,42,55,56,44,0,42,55,56,44,31,0}, {0,41,66,68,45,0,41,66,68,45,0,0} },	//43 ISPRAVI
		{ {21,42,55,68,58,33}, {32,31,43,56,57,45,31,43,56,57,45,32}, {22,30,0,67,69,46,30,0,67,69,46,22} },	//44
		{ {22,31,56,69,59,34}, {33,32,44,57,58,46,32,44,57,58,46,33}, {23,21,43,68,70,47,21,43,68,70,47,23} },	//45
		{ {23,32,57,70,60,35}, {34,33,45,58,59,47,33,45,58,59,47,34}, {24,22,44,69,71,48,22,44,69,71,48,24} },	//46
		{ {24,33,58,71,61,36}, {35,34,46,59,60,48,34,46,59,60,48,35}, {25,23,45,70,72,49,23,45,70,72,49,25} },	//47
		{ {25,34,59,72,0,0}, {36,35,47,60,61,49,35,47,60,61,49,36}, {0,24,46,71,0,0,24,46,71,0,0,0} },	//48
		{ {0,35,60,0,0,0}, {0,36,48,61,0,0,36,48,61,48,0,0}, {0,0,47,0,0,0,0,47,0,0,0,0} },	//49
		{ {63,39,26,0,0,0}, {62,51,38,37,0,0,51,38,37,0,0,62}, {0,52,27,0,0,0,52,27,0,0,0,0} },	//50
		{ {37,0,73,64,40,27}, {38,50,62,63,52,39,50,62,63,52,39,38}, {26,0,0,74,53,28,0,0,74,53,28,26} },	//51
		{ {38,62,74,65,41,28}, {39,51,63,64,53,40,51,63,64,53,40,39}, {27,50,73,75,54,29,50,73,75,54,29,27} },	//52
		{ {39,63,75,66,42,29}, {40,52,64,65,54,41,52,64,65,54,41,40}, {28,51,74,76,55,30,51,74,76,55,30,28} },	//53
		{ {40,64,76,67,43,30}, {41,53,65,66,55,42,53,65,66,55,42,41}, {29,52,75,77,56,31,52,75,77,56,31,29} },	//54
		{ {41,65,77,68,44,31}, {42,54,66,67,56,43,54,66,67,56,43,42}, {30,53,76,78,57,0,53,76,78,57,0,30} },	//55
		{ {42,66,78,69,45,31}, {43,55,67,68,57,44,55,67,68,57,44,43}, {0,54,77,79,58,32,54,77,79,58,32,0} },	//56
		{ {43,67,79,70,46,32}, {44,56,68,69,58,45,56,68,69,58,45,44}, {31,55,78,80,59,33,55,78,80,59,33,31} },	//57
		{ {44,68,80,71,47,33}, {45,57,69,70,59,46,57,69,70,59,46,45}, {32,56,79,81,60,34,56,79,81,60,34,32} },	//58
		{ {45,69,81,72,48,34}, {46,58,70,71,60,47,58,70,71,60,47,46}, {33,57,80,82,61,35,57,80,82,61,35,33} },	//59
		{ {46,70,82,0,49,35}, {47,59,71,72,61,48,59,71,72,61,48,47}, {34,58,81,0,0,36,58,81,0,0,36,34} },	//60
		{ {47,71,0,0,0,36}, {48,60,72,0,0,49,60,72,0,0,49,48}, {35,59,0,0,0,0,59,0,0,0,0,35} },	//61
		{ {74,52,38,0,0,0}, {73,63,51,50,0,0,63,51,50,0,0,73}, {0,64,39,0,0,0,64,39,0,0,0,0} },	//62
		{ {50,0,83,75,53,39}, {51,62,73,74,64,52,62,73,74,64,52,51}, {38,0,0,84,65,40,0,0,84,65,40,38} },	//63
		{ {51,73,84,76,54,40}, {52,63,74,75,65,53,63,74,75,65,53,52}, {39,62,83,85,66,41,62,83,85,66,41,39} },	//64
		{ {52,74,85,77,55,41}, {53,64,75,76,66,54,64,75,76,66,54,53}, {40,63,84,86,67,42,63,84,86,67,42,40} },	//65
		{ {53,75,86,78,56,42}, {54,65,76,77,67,55,65,76,77,67,55,54}, {41,64,85,87,68,43,64,85,87,68,43,41} },	//66
		{ {54,76,87,79,57,43}, {55,66,77,78,68,56,66,77,78,68,56,55}, {42,65,86,88,69,44,65,86,88,69,44,42} },	//67
		{ {55,77,88,80,58,44}, {56,67,78,79,69,57,67,78,79,69,57,56}, {43,66,87,89,70,45,66,87,89,70,45,43} },	//68
		{ {56,78,89,81,59,45}, {57,68,79,80,70,58,68,79,80,70,58,57}, {44,67,88,90,71,46,67,88,90,71,46,44} },	//69
		{ {57,79,90,82,60,46}, {58,69,80,81,71,59,69,80,81,71,59,58}, {45,68,89,91,72,47,68,89,91,72,47,45} },	//70
		{ {58,80,91,0,61,47}, {59,70,81,82,72,60,70,81,82,72,60,59}, {46,69,90,0,0,48,69,90,0,0,48,46} },	//71
		{ {59,81,0,0,0,48}, {60,71,82,0,0,61,71,82,0,0,61,60}, {47,70,0,0,0,0,70,0,0,0,0,47} },	//72
		{ {84,64,51,0,0,0}, {83,74,63,62,0,0,74,63,62,0,0,83}, {0,75,52,0,0,0,75,52,0,0,0,0} },	//73
		{ {62,0,92,85,65,52}, {63,73,83,84,75,64,73,83,84,75,64,63}, {51,0,0,93,76,53,0,0,93,76,53,51} },	//74
		{ {63,83,93,86,66,53}, {64,74,84,85,76,65,74,84,85,76,65,64}, {52,73,92,94,77,54,73,92,94,77,54,52} },	//75
		{ {64,84,94,87,67,54}, {65,75,85,86,77,66,75,85,86,77,66,65}, {53,74,93,95,78,55,74,93,95,78,55,53} },	//76
		{ {65,85,95,88,68,55}, {66,76,86,87,78,67,76,86,87,78,67,66}, {54,75,94,96,79,56,75,94,96,79,56,54} },	//77
		{ {66,86,96,89,69,56}, {67,77,87,88,79,68,77,87,88,79,68,67}, {55,76,95,97,80,57,76,95,97,80,57,55} },	//78
		{ {67,87,97,90,70,57}, {68,78,88,89,80,69,78,88,89,80,69,68}, {56,77,96,98,81,58,77,96,98,81,58,56} },	//79
		{ {68,88,98,91,71,58}, {69,79,89,90,81,70,79,89,90,81,70,69}, {57,78,97,99,82,59,78,97,99,82,59,57} },	//80
		{ {69,89,99,0,72,59}, {70,80,90,91,82,71,80,90,91,82,71,70}, {58,79,98,0,0,60,79,98,0,0,60,58} },	//81
		{ {70,90,0,0,0,60}, {71,81,91,0,0,72,81,91,0,0,72,71}, {59,80,0,0,0,0,80,0,0,0,0,59} },	//82
		{ {93,75,63,0,0,0}, {92,84,74,73,0,0,84,74,73,0,0,92}, {0,85,64,0,0,0,85,64,0,0,0,0} },	//83
		{ {73,0,100,94,76,64}, {74,83,92,93,85,75,83,92,93,85,75,74}, {63,0,0,101,86,65,0,0,101,86,65,63} },	//84
		{ {74,92,101,95,77,65}, {75,84,93,94,86,76,84,93,94,86,76,75}, {64,83,100,102,87,66,83,100,102,87,66,64} },	//85
		{ {75,93,102,96,78,66}, {76,85,94,95,87,77,85,94,95,87,77,76}, {65,84,101,103,88,67,84,101,103,88,67,65} },	//86
		{ {76,94,103,97,79,67}, {77,86,95,96,88,78,86,95,96,88,78,77}, {66,85,102,104,89,68,85,102,104,89,68,66} },	//87
		{ {77,95,104,98,80,68}, {78,87,96,97,89,79,87,96,97,89,79,78}, {67,86,103,105,90,69,86,103,105,90,69,67} },	//88
		{ {78,96,105,99,81,69}, {79,88,97,98,90,80,88,97,98,90,80,79}, {68,87,104,106,91,70,87,104,106,91,70,68} },	//89
		{ {79,97,106,0,82,70}, {80,89,98,99,91,81,89,98,99,91,81,80}, {69,88,105,0,0,71,88,105,0,0,71,69} },	//90
		{ {80,98,0,0,0,71}, {81,90,99,0,0,82,90,99,0,0,82,81}, {70,89,0,0,0,0,89,0,0,0,0,70} },	//91
		{ {101,85,74,0,0,0}, {100,93,84,83,0,0,93,84,83,0,0,100}, {0,94,75,0,0,0,94,75,0,0,0,0} },	//92
		{ {83,0,0,102,86,75}, {84,92,100,101,94,85,92,100,101,94,85,84}, {74,0,0,0,95,76,0,0,0,95,76,74} },	//93
		{ {84,100,0,103,87,76}, {85,93,101,102,95,86,93,101,102,95,86,85}, {75,92,0,0,96,77,92,0,0,96,77,75} },	//94
		{ {85,101,0,104,88,77}, {86,94,102,103,96,87,94,102,103,96,87,86}, {76,93,0,0,97,78,93,0,0,97,78,76} },	//95
		{ {86,102,0,105,89,78}, {87,95,103,104,97,88,95,103,104,97,88,87}, {77,94,0,0,98,79,94,0,0,98,79,77} },	//96
		{ {87,103,0,106,90,79}, {88,96,104,105,98,89,96,104,105,98,89,88}, {78,95,0,0,99,80,95,0,0,99,80,78} },	//97
		{ {88,104,0,0,91,80}, {89,97,105,106,99,90,97,105,106,99,90,89}, {79,96,0,0,0,81,96,0,0,0,81,79} },	//98
		{ {89,105,0,0,0,81}, {90,98,106,0,0,91,98,106,0,0,91,90}, {80,97,0,0,0,0,97,0,0,0,0,80} },	//99
		{ {94,84,0,0,0,0}, {101,93,92,0,0,0,93,92,0,0,0,0}, {0,85,0,0,0,0,85,0,0,0,0,0} },	//100
		{ {92,0,0,0,95,85}, {93,100,0,0,102,94,100,0,0,102,94,93}, {84,0,0,0,0,86,0,0,0,0,86,84} },	//101
		{ {93,0,0,0,96,86}, {94,101,0,0,103,95,101,0,0,103,95,94}, {85,0,0,0,0,87,0,0,0,0,87,85} },	//102
		{ {94,0,0,0,97,87}, {95,102,0,0,104,96,102,0,0,104,96,95}, {86,0,0,0,0,88,0,0,0,0,88,86} },	//103
		{ {95,0,0,0,98,88}, {96,103,0,0,105,97,103,0,0,105,97,96}, {87,0,0,0,0,89,0,0,0,0,89,87} },	//104
		{ {96,0,0,0,99,89}, {97,104,0,0,106,98,104,0,0,106,98,97}, {88,0,0,0,0,90,0,0,0,0,90,88} },	//105
		{ {97,0,0,0,0,90}, {98,105,0,0,0,99,105,0,0,0,99,98}, {89,0,0,0,0,0,0,0,0,0,0,89} }	//106
		};

typedef struct dorubni {
	int ind;
	int kl[2];
	int sl[2];
} dorubni;

typedef struct dorubni popisdorubni[ 25 ];

popisdorubni rv = {	{0,{0,0},{0,0}},
			{6,{2,5},{1,10}},
			{11,{5,10},{2,17}},
			{18,{10,17},{5,26}},
			{27,{17,26},{10,37}},
			{0,{0,0},{0,0}},
			{51,{50,62},{37,73}},
			{63,{62,73},{50,83}},
			{74,{73,83},{62,92}},
			{84,{83,92},{73,100}},
			{0,{0,0},{0,0}},
			{94,{101,102},{100,103}},
			{95,{102,103},{101,104}},
			{96,{103,104},{102,105}},
			{97,{104,105},{103,106}},
			{0,{0,0},{0,0}},
			{90,{99,91},{106,82}},
			{81,{91,82},{99,72}},
			{71,{82,72},{91,61}},
			{60,{72,61},{82,49}},
			{0,{0,0},{0,0}},
			{35,{36,25},{49,16}},
			{24,{25,16},{39,9}},
			{15,{16,9},{25,4}},
			{8,{9,4},{16,1}},
		};

int listazamijeni[dulj+1] = {
			0,	//0
			-1,	//1
			60,	//2
			-1,	//3
			51,	//4
			0,	//5
			-1,	//6
			-1,	//7
			-1,	//8
			0,	//9
			0,	//10
			0,	//11
			-1,	//12
			0,	//13
			-1,	//14
			0,	//15
			0,	//16
			0,	//17
			0,	//18
			0,	//19
			0,	//20
			-1,	//21
			-1,	//22
			0,	//23
			0,	//24
			0,	//25
			60,	//26
			-1,	//27
			-1,	//28
			0,	//29
			-1,	//30
			-1,	//31
			-1,	//32
			-1,	//33
			-1,	//34
			-1,	//35
			84,	//36
			-1,	//37
			-1,	//38
			-1,	//39
			0,	//40
			-1,	//41
			-1,	//42
			-1,	//43
			-1,	//44
			-1,	//45
			0,	//46
			-1,	//47
			-1,	//48
			-1,	//49
			90,	//50
			-1,	//51
			-1,	//52
			0,	//53
			-1,	//54
			-1,	//55
			-1,	//56
			0,	//57
			-1,	//58
			-1,	//59
			-1,	//60
			51,	//61
			0,	//62
			0,	//63
			0,	//64
			0,	//65
			-1,	//66
			-1,	//67
			-1,	//68
			-1,	//69
			0,	//70
			0,	//71
			0,	//72
			0,	//73
			0,	//74
			-1,	//75
			0,	//76
			0,	//77
			0,	//78
			0,	//79
			-1,	//80
			-1,	//81
			0,	//82
			0,	//83
			-1,	//84
			-1,	//85
			-1,	//86
			0,	//87
			-1,	//88
			-1,	//89
			-1,	//90
			0,	//91
			8,	//92
			-1,	//93
			-1,	//94
			0,	//95
			0,	//96
			-1,	//97
			-1,	//98
			6,	//99
			-1,	//100
			35,	//101
			0,	//102
			0,	//103
			0,	//104
			27,	//105
			-1,	//106			
			};

int stranica[5][7] = {	{1,2,5,10,17,26,37},
			{37,50,62,73,83,92,100},
			{100, 101, 102,103,104,105,106},
			{106,99,91,82,72,61,49},
			{49,36,25,16,9,4,1}
			};


typedef struct atom {
	int ind;
	struct atom *next;
} atom;

typedef struct skupina2 {
	atom *pocetak;
	atom *kraj;
	int brojkamenja;
	int str1;
	int str2;
	int str3;
	int str4;
	int str5;
	//struct skupina *next;
}skupina2; 

atom *bijelikraj, *crnikraj , *bijeli2, *crni2, *alfa, *omega;
skupina2 bijeleskupine[ 20 ];
skupina2 crneskupine[ 20 ];
int brskupinabijeli, brskupinacrni; 

int nbrfree, nbrmalloc, amalloc = 0, afree = 0, udmall = 0, udfree = 0;
int pi = 0;

typedef struct kandidat {
	atom *p;
	int svalue;
	int str;
	int gain;
	int ud_v;
	int ocjena;
	int igra;
	struct kandidat *next;
} kandidat;

typedef struct klaster {
	atom *grupa;
	int count;
	int tip;
	struct klaster *next;
} klaster;

typedef struct skupina {
	atom *nizkamen;
	klaster *forsirani;
	int value;//nije implementir
	int brojkamenja, brstr, brvrh;
	int mstr[ 4 ];
	int str[ 6 ];
	int vrh[ 6 ];
	struct skupina *next;
}skupina; 

typedef struct pozicija {
	atom	*igrac, *protivnik;
	skupina *igracskupine, *protivnikskupine;
	int 	mbrstr, pbrstr, ivrh[6], pvrh[6];
	int	lanacigrac, lanacprotivnik;
	int	brskupinaigrac;
	int     brskupinaprotivnik;
	int  	ocjena;
	//klaster	*forsigrac, *forsprotivnik;
	atom	*potezi;
	atom 	*buff;
} pozicija;

typedef struct node {
	char potez;
	char odigrao;
	int alfa;
	int beta;
	int ocjena;
	struct node *firstchild;
	struct node *sibling;
	struct node *parent;
} node;

typedef struct node2 {
	int potez;
	int odigrao;
	int alfa;
	int beta;
	int ocjena;
	struct node *firstchild;
	struct node *sibling;
	struct node *parent;
} node2;

struct timeval start, end;
double razmisljao, potroseno_vrijeme;
node *root = NULL;
pozicija *test = NULL;
atom *igrac = NULL, *protivnik = NULL, *kand = NULL;
kandidat *gk = NULL;
int ud[ dulj+1 ][5], up[ dulj+1 ][5], fl[ dulj+1 ], igr[ dulj+1 ], prot[ dulj+1 ];
int moves = 0;
int choice;
int uk_p = 0; 
int verbose = 0;
int prvi=0;

atom *lsg=NULL;
//int flag[107];

void nulltest( atom **a,atom **b );

void initploca( ploca p );
int rdstdin( int *d );
int *vratisusjede( int ind, int printaj );

int provjeriskupine( skupina2 **popis, int brskupina );
void Zamijeni( atom **bpocetak, atom **bkraj, atom ** cpocetak, atom ** ckraj );
void UniznaKraj( atom **pocetak, atom **kraj, int ind );
atom  *VanizNiza( atom ** pocetak, atom  **kraj, int ind );

void zamijeni( atom **b, atom **c);// ne radi uopce!!!! korisitim stari zamijeni

//funkcije vezane uz poziciju
int susjed( int ind1, int ind2, klaster **cloud);
int susjedp( int ind1, int ind2, klaster **cloud);
atom *kopirajniz( atom *stari );
atom *noviatom( int ind );
atom *kraj( atom *pocetak );// ne radi dobro
atom *trazi( atom *pocetak, int ind );
void Ispisi( atom * list );
void dodaj( atom **pocetak, int ind );
void ubaci( atom **pocetak, atom *arg );
atom *izbaci( atom **pocetak, int ind );
void obrisi( atom *arg);
int obrisiniz( atom **niz);
skupina *skupineigrac( pozicija **bazen );
skupina *skupineprotivnik( pozicija **bazen );
skupina *novaskupina();
void obrisiskupine( skupina **sk);
void ubaciskupinu( skupina **pocetak, skupina *arg );
void skupinasusjed( atom **buff, atom **niz, int kamen, klaster **forsirani);
void skupinasusjedp( atom **buff, atom **niz, int kamen, klaster **forsirani);
void pregledajskupine( skupina *popis, int *lanac, int vrh[5]);
void ispisipoziciju( pozicija board );
pozicija *novapozicija( atom *igracset, atom *protivnikset );
int setpozicija( pozicija **arg, atom *igracset, atom *protivnikset );
int fact( int n);
int dostr( pozicija **arg);
skupina *skupind( skupina *arg, int pot);
void udaljenost( int depth, atom **lu, int fl[dulj+1], int str);
void racunajudaljenost( pozicija **p, int trazenastranica);
void udaljenostp( int depth, atom **lu, int fl[dulj+1], int str);
void racunajudaljenostp( pozicija **p, int trazenastranica);
void namjestib( atom *igrac, atom *protivnik);
klaster dodajklaster( klaster **pocetak, atom *niz, int count, int tip);
int obrisiklasterniz( klaster **arg);
void rubniklaster( pozicija *arg);
void vrhudaljenost();


//funkcije vezane uz stablo poteza
node *novinode( node **parent, int potez );
node *izbacinode( node **parent, int potez ); //izbacuje ali NE briše
void obrisinode( node *arg );//briše SAMOSTALNI node i svu djecu, jer ne pazi da li je dio postojece liste 
//void obrisinode2(node **arg); 
node *nadjichild( node *arg, int potez );
node *parent( node *arg );
atom *listasusjeda( atom *igrac, atom *protivnik);
atom *kandidati( pozicija **board, atom *igrac, atom *protivnik);
node *kreirajstablo( int dubina, node **arg, atom *igrac, atom *protivnik);
int alfabeta( node **arg, int dubina, int alfa, int beta, atom *igracset, atom *protivnikset, pozicija **pz, int player, int *izbor);
int alfabetak( node **arg, int dubina, int alfa, int beta, atom *igrac, atom *protivnik, pozicija **pz, int player, int *izbor);
int alfabetan( int dubina, int alfa, int beta, atom *igrac, atom *protivnik, pozicija **pz, int player, int *izbor);
int alfabetag( node **arg, int dubina, int alfa, int beta, atom *igracset, atom *protivnikset, pozicija **pz, int player, int *izbor);
int cmpnode(node *a, node *b, int silazno);
node *sortlist( node *arg, int silazno);
atom *generirajpoteze( pozicija *p);
kandidat *generirajkandidate( pozicija *p);
skupina *nadjiskupinu( skupina *arg, int ind);
atom *a_l_k( kandidat *arg);
int cmpkand(kandidat *a, kandidat *b, int silazno); 
kandidat *sortkandidate( kandidat *arg, int silazno);
void ispisikandidate( kandidat *arg);

node *nadjipotez( node *arg);
int dokorijen( atom **niz, node *arg, int p);

//vezano uz kretanje po stablu u main-u
void ispisidjecu( node *parent );//ne radi ispisivanje parenta!!!!
void ispisipotez( node *arg );

void IGRAJ( int zadnjipotez);



//----------------------------------funkcije------------------------------------------------
//funkcija susjed sa igrackamen onaj sa najmanje susjeda odaberi na listi poteza 

void IGRAJ( int zadnjipotez)
{
	//izmjeri vrijeme
	gettimeofday(&start, NULL);	

	//printf ("verbose %d", verbose);
	 //ispisipoziciju( *test);
	skupina *it;
	klaster *k;
	atom *kam, *zp;
	int kc;
//prvi potez
	if (!moves && !verbose)	
	{
		choice = listazamijeni[ zadnjipotez];
		if (choice == -1)
		{
			obrisi( izbaci( &protivnik, zadnjipotez));
			obrisi( izbaci( &igrac, -1));
			dodaj( &igrac, zadnjipotez);
			printf("%d\n", choice);
			moves++;
			fflush(stdout);
			return;
		}
		if (choice) goto kraj;
	}
	
	if ((moves == 1) && (zadnjipotez == -1))
	{
				choice = 8;
				goto kraj;
	}	
	
	if (moves == 4)
	{
			kc = 0;
				kam = igrac;
						while ( kam)
						{			
							kc += kam->ind*kam->ind;
							kam = kam->next;
						}
				
				kam = protivnik;
						while ( kam)
						{			
							kc += kam->ind*kam->ind;
							kam = kam->next;
						}
			if (kc == 4900) 
			{
				choice = 52;
				goto kraj;
			}
			
				
	}

	if (moves == 5)
	{
			kc = 0;
				kam = igrac;
						while ( kam)
						{			
							kc += kam->ind*kam->ind;
							kam = kam->next;
						}
				
				kam = protivnik;
						while ( kam)
						{			
							kc += kam->ind*kam->ind;
							kam = kam->next;
						}
			if (kc == 11829) 
			{
				choice = 74;
				goto kraj;
			}
			
				
	}

	
	int sp = setpozicija( &test, igrac, protivnik);
	if (!((sp >= WIN) || (sp <= -WIN))) 
	{	
		if (zadnjipotez != 0)
		{
			pi = 0;
				//obrisinode( root );
			zp = izbaci( &protivnik, zadnjipotez);
			setpozicija( &test, igrac, protivnik);// samo radi forsiranih bez zadnjeg poteza
			ubaci( &protivnik, zp);
			it = test->igracskupine;
			while ( it != NULL)
			{
				k = it->forsirani;
				while ( k != NULL )
				{
					kam = k->grupa;
						kc = 0;
						if (((k->tip < 2) && (k->count < 3)) || ((k->tip == 2) && ((k->count == 4)||(k->count < 3))))
						while ( kam)
						{			
							if (kam->ind == zadnjipotez)
							{
								if (kc)	choice = k->grupa->ind;
								else choice = kam->next->ind;
								goto kraj;
							} 
							kc++;
							kam = kam->next;
						}
					k = k->next;
				}
				it = it->next;
			}
		}

		if ( WIN <= alfabetag( &root, 1, -2*WIN, +2*WIN, igrac, protivnik, &test, 1, &choice))	
		//if ( WIN <= alfabetan( 1, -2*WIN, +2*WIN, igrac, protivnik, &test, 1, &choice))	
		{

//		Zug
			//dodaj( &igrac, choice);
			goto kraj;
			//if (verbose) printf("Zug zwang - alfabeta: WIN\n");
			//if (verbose) np = setpozicija( &test, igrac, protivnik);
		
		}
		else 
		{
//			provjeri zadnji potez u forsiranim
	
			pi = 0;		obrisinode( root );
			root = NULL;
			sp = alfabetak( &root, 4, -2*WIN, +2*WIN, igrac, protivnik, &test, 1, &choice);
			//sp = alfabeta( &root, 3, -2*WIN, +2*WIN, igrac, protivnik, &test, 1, &choice);
			//root->firstchild = sortlist( root, 1);
			//choice = root->firstchild->potez;
			//sp = alfabetan( 3, -2*WIN, +2*WIN, igrac, protivnik, &test, 1, &choice);
			//printf ( "choice %d\n", choice);
			/*if ( sp > WIN) ;//dodaj( &igrac, choice);
			else {
			np = setpozicija( &test, igrac, protivnik);
			if (verbose)	printf ("np-sp %d\n",np - sp);
			if ((np - sp) < 3) 
			{
				if (verbose) printf(" null move\n");// null move
				//listapoteza
				atom *it = kandidati( &test, igrac, protivnik);
				atom *dt;
				kand = it;
				int maxk = -WIN;
				int move = 0, ch;
					//if (verbose) printf ("kandidati: ");
					//if (verbose) Ispisi( it);
				while ( it != NULL)
				{
					
					dodaj( &igrac, it->ind);
					pi = 0;
					move = alfabetan( 3, -2*WIN, +2*WIN, igrac, protivnik, &test, 0, &ch);
					obrisi( izbaci( &igrac, it->ind));
					//obrisinode( root);
					if (verbose)  printf("%d  ocj:%d pi: %d\n", it->ind, move, pi );
					if ( maxk <= move)	
					{
						maxk = move; 
						
						choice = it->ind;
					}  
					dt = it->next;
					it = dt;
				} 
					//dodaj( &igrac, choice);


			}
			}
//			if (np)
				*/
		}
	}
	else 
	{
			zp = izbaci( &protivnik, zadnjipotez);
			setpozicija( &test, igrac, protivnik);// samo radi forsiranih bez zadnjeg poteza
			ubaci( &protivnik, zp);
			it = test->igracskupine;
			while ( it != NULL)
			{
				k = it->forsirani;
				while ( k != NULL)
				{
					kam = k->grupa;
						kc = 0;
						//if (((k->tip < 2) && (k->count < 3)) || ((k->tip == 2) && ((k->count == 4)||(k->count < 3))))
						while ( kam)
						{			
							if (kam->ind == zadnjipotez)
							{
								if (kc)	choice = k->grupa->ind;
								else choice = kam->next->ind;
								goto kraj;
							} 
							kc++;
							kam = kam->next;
						}
							k = k->next;
					
				}
				it = it->next;
			}
			it = test->igracskupine;
			while ( it != NULL)
			{
				k = it->forsirani;
				while ( k != NULL)
				{
					kam = k->grupa;
					while ( kam != NULL)
					{
								choice = k->grupa->ind;
								goto kraj;
					}
					k = k->next;
				}
				it = it->next;
			}
	}
					
			kraj :	
			dodaj( &igrac, choice);
// izmjeri vrijeme	
			gettimeofday(&end, NULL);	
			razmisljao = (end.tv_sec - start.tv_sec) + (end.tv_usec - start.tv_usec) / 1000000.0;
 			fprintf(stderr, "%d time %f v %f am %d af %d nm %d nf %d\n", choice, razmisljao, pi/razmisljao, amalloc, afree, nbrmalloc, nbrfree); 
			potroseno_vrijeme += razmisljao;
			uk_p += pi; 
			printf("%d\n", choice);
			if (verbose) printf("alfabeta: %d\n", sp);
			moves++;
			fflush(stdout);

	//printf ( "poslije igraj");
	setpozicija( &test, igrac, protivnik);//pitaanje da li je potrebno
	if (verbose)  ispisipoziciju( *test);
}

void vrhudaljenost()
{
	int buf[dulj+1],i,str;
	
for (i = 1; i < dulj+1; i++) 
{
buf[i] = ud[i][4]; 		//printf("%d %d\n", i ,ud[i][str]);
}

for (str = 4; str > 0; str --)	for (i = 1; i < dulj+1; i++) ud[i][str] = (ud[i][str] > ud[i][(str+4)%5]) ? ud[i][str] : ud[i][(str+4)%5];
for (i = 1; i < dulj+1; i++) ud[i][4] = (ud[i][0] > buf[i]) ? ud[i][0] : buf[i];

for (i = 1; i < dulj+1; i++) buf[i] = up[i][4];
for (str = 4; str > 0; str --)	for (i = 1; i < dulj+1; i++) up[i][str] = (up[i][str] > up[i][(str+4)%5]) ? up[i][str] : up[i][(str+4)%5];
for (i = 1; i < dulj+1; i++) up[i][4] = (up[i][0] > buf[i]) ? up[i][0] : buf[i];

}

void ispisikandidate( kandidat *arg)
{
	kandidat *k;
	for ( k = arg; k; k = k->next)
	{
		printf("%d ->%d sval %d str %d g %d ud %d\n", k->p->ind, k->ocjena, k->svalue, k->str, k->gain, k->ud_v);
	
	}
}

atom *a_l_k( kandidat *arg)
{
	atom *l = NULL;
	kandidat *k;
	for ( k = arg; k; k = k->next) dodaj( &l, k->p->ind);
	return l;
}

void dodajkandidat( kandidat **pocetak, int ind, int sv, int str, int g, int u, int igra)
{

	kandidat *novi = *pocetak;
	
	*pocetak = malloc(sizeof(kandidat));
	(*pocetak)->p = noviatom( ind);
	(*pocetak)->svalue = sv;
	(*pocetak)->str = str;
	(*pocetak)->gain = g;
	(*pocetak)->ud_v = u;
	(*pocetak)->igra = igra;
	(*pocetak)->ocjena = sv*100 - g;

	(*pocetak)->next = novi;
}

void obrisikandidat( kandidat *arg)
{
	//printf("afree %d\n", arg->ind);
	free( arg);
}

int obrisikandidate( kandidat **niz) //brise ali ne ne postavlja pokazivac prethodnog NULL
{
	kandidat *p;
	int c = 0;
	while (*niz != NULL) 
	{
		p = *niz;
		*niz = (*niz)->next;
		//printf("afree %d\n", p->ind);	
		free( p->p);
		free( p);
		c++;
	}
	return c;
}

kandidat *izbacikandidat( kandidat **pocetak, int ind )
//izbacuje iz skupine ali ne briše iz memorije!!
{
	kandidat *temp = *pocetak;
	kandidat *prev = NULL;
	//atom * ret;
	while (temp != NULL)
	{
		if (temp->p->ind == ind) 
		{
			if (prev != NULL) prev->next = temp->next;
			else *pocetak = temp->next;
			temp->next = NULL;
			return temp;
		}
		prev = temp;
		temp = temp->next;
	}
	return NULL;
}

skupina *nadjiskupinu( skupina *arg, int ind)
{
	skupina *s;
	atom *a;
	for ( s = arg; s; s = s->next)
		for ( a = s->nizkamen; a; a = a->next)
			if ( a->ind == ind )	return s;
	return NULL;
}

void rubniklaster( pozicija *arg)
{
	int ci, cp, i = 0;
	skupina *s;
	atom *niz;
	while ( i < 26)
	{
		ci = 0;
		niz = NULL;
	
		while ( b[ rv[i].ind].igrac)
		{
			//printf("i* %d\n",rv[i].ind);
			if (!( b[ rv[i].kl[0]].igrac || b[ rv[i].kl[0]].protivnik || b[ rv[i].kl[1]].igrac || 
				b[ rv[i].kl[1]].protivnik || b[ rv[i].sl[0]].igrac || b[ rv[i].sl[1]].igrac))
			{
				if (!ci)	
				{
					s = nadjiskupinu( arg->igracskupine, rv[i].ind);
					dodaj( &niz, rv[i].kl[0]);
					ci++;
					switch (b[rv[i].kl[0]].boja)
					{
						case 6: s->str[0] = 1; break;
						case 7: s->str[1] = 1; break;	
						case 8: s->str[2] = 1; break;
						case 9: s->str[3] = 1; break;
						case 10: s->str[4] = 1; break;
					}
				}
				dodaj( &niz, rv[i].kl[1]);
				ci++;
			}
			i++;
		}
		if (ci) 
		{
			dodajklaster( &(s->forsirani), niz, ci, 1);
		}
		i++;
	}
	i = 0;
	while ( i < 26)
	{
		cp = 0;
		niz = NULL;
		while ( b[ rv[i].ind].protivnik)
		{
			/*printf("p %d u %d %d %d %d (%d)\n",rv[i].ind,b[ rv[i].kl[0]].igrac, b[ rv[i].kl[0]].protivnik, b[ rv[i].kl[1]].igrac, b[ rv[i].kl[1]].protivnik,(!( b[ rv[i].kl[0]].igrac || b[ rv[i].kl[0]].protivnik || b[ rv[i].kl[1]].igrac || 
				b[ rv[i].kl[1]].protivnik || b[ rv[i].sl[0]].protivnik || b[ rv[i].sl[1]].protivnik)));*/
			if (!( b[ rv[i].kl[0]].igrac || b[ rv[i].kl[0]].protivnik || b[ rv[i].kl[1]].igrac || 
				b[ rv[i].kl[1]].protivnik || b[ rv[i].sl[0]].protivnik || b[ rv[i].sl[1]].protivnik))
			{
				//printf("*\n");
				if (!cp)	
				{
					s = nadjiskupinu( arg->protivnikskupine, rv[i].ind);
					dodaj( &niz, rv[i].kl[0]);
					cp++;
					switch (b[rv[i].kl[0]].boja)
					{
						case 6: s->str[0] = 1; break;
						case 7: s->str[1] = 1; break;	
						case 8: s->str[2] = 1; break;
						case 9: s->str[3] = 1; break;
						case 10: s->str[4] = 1; break;
					}
				}
				dodaj( &niz, rv[i].kl[1]);
				cp++;
			}
			i++;
		}
		if (cp) 
		{
			dodajklaster( &(s->forsirani), niz, cp, 1);
		}
		i++;
	}
	
}

int cmpkand( kandidat *a, kandidat *b, int silazno) 
{
	if ( silazno )	return - a->ocjena + b->ocjena;
	else return  a->ocjena - b->ocjena;
}

kandidat *sortkandidate( kandidat *arg, int silazno)
{
	kandidat *p, *q, *e, *tail, *list;
	int insize, nmerges, psize, qsize, i;

	if (!arg)
	return NULL;
	
	/*if ( !arg->firstchild )	return NULL;
	else	list = arg->firstchild;*/

	list = arg;

	insize = 1;

	while (1) 
	{
		p = list;
		list = NULL;
		tail = NULL;

	        nmerges = 0;  /* count number of merges we do in this pass */

	        while (p) 
		{
			nmerges++;  /* there exists a merge to be done */
		        /* step `insize' places along from p */
			q = p;
			psize = 0;
			for (i = 0; i < insize; i++) 
			{
				psize++;
				q = q->next;
				if (!q) break;
			}

			/* if q hasn't fallen off end, we have two lists to merge */
			qsize = insize;
	
			/* now we have two lists; merge them */
			while (psize > 0 || (qsize > 0 && q)) 
			{

				/* decide whether next element of merge comes from p or q */
				if (psize == 0) 
				{
					/* p is empty; e must come from q. */
					e = q; q = q->next; qsize--;
					//if (is_circular && q == oldhead) q = NULL;
				} 
				else if (qsize == 0 || !q) 
				{
				    /* q is empty; e must come from p. */
				    e = p; p = p->next; psize--;
				    //if (is_circular && p == oldhead) p = NULL;
				} 
				else if ( cmpkand( p, q, silazno) <= 0) 
				{
				    /* First element of p is lower (or same);
				     * e must come from p. */
				    e = p; p = p->next; psize--;
				   // if (is_circular && p == oldhead) p = NULL;
				} 
				else 
				{
				    /* First element of q is lower; e must come from q. */
				    e = q; q = q->next; qsize--;
				    //if (is_circular && q == oldhead) q = NULL;
				}
	
		                /* add the next element to the merged list */
				if (tail) 
				{
				    tail->next = e;
				} 
				else 
				{
					list = e;
				}
				tail = e;
			}
	
			/* now p has stepped `insize' places along, and q has too */
			p = q;
		}
		tail->next = NULL;

        /* If we have done only one merge, we're finished. */
		if (nmerges <= 1)   /* allow for nmerges==0, the empty list case */
		return list;

        /* Otherwise repeat, merging lists twice the size */
		insize *= 2;
	}
}


node *sortlist( node *arg, int silazno)
{
	node *p, *q, *e, *tail, *list;
	int insize, nmerges, psize, qsize, i;

	if (!arg)
	return NULL;
	
	if ( !arg->firstchild )	return NULL;
	else	list = arg->firstchild;
	
	insize = 1;

	while (1) 
	{
		p = list;
		list = NULL;
		tail = NULL;

	        nmerges = 0;  /* count number of merges we do in this pass */

	        while (p) 
		{
			nmerges++;  /* there exists a merge to be done */
		        /* step `insize' places along from p */
			q = p;
			psize = 0;
			for (i = 0; i < insize; i++) 
			{
				psize++;
				q = q->sibling;
				if (!q) break;
			}

			/* if q hasn't fallen off end, we have two lists to merge */
			qsize = insize;
	
			/* now we have two lists; merge them */
			while (psize > 0 || (qsize > 0 && q)) 
			{

				/* decide whether next element of merge comes from p or q */
				if (psize == 0) 
				{
					/* p is empty; e must come from q. */
					e = q; q = q->sibling; qsize--;
					//if (is_circular && q == oldhead) q = NULL;
				} 
				else if (qsize == 0 || !q) 
				{
				    /* q is empty; e must come from p. */
				    e = p; p = p->sibling; psize--;
				    //if (is_circular && p == oldhead) p = NULL;
				} 
				else if ( cmpnode( p, q, silazno) <= 0) 
				{
				    /* First element of p is lower (or same);
				     * e must come from p. */
				    e = p; p = p->sibling; psize--;
				   // if (is_circular && p == oldhead) p = NULL;
				} 
				else 
				{
				    /* First element of q is lower; e must come from q. */
				    e = q; q = q->sibling; qsize--;
				    //if (is_circular && q == oldhead) q = NULL;
				}
	
		                /* add the next element to the merged list */
				if (tail) 
				{
				    tail->sibling = e;
				} 
				else 
				{
					list = e;
				}
				tail = e;
			}
	
			/* now p has stepped `insize' places along, and q has too */
			p = q;
		}
		tail->sibling = NULL;

        /* If we have done only one merge, we're finished. */
		if (nmerges <= 1)   /* allow for nmerges==0, the empty list case */
		return list;

        /* Otherwise repeat, merging lists twice the size */
		insize *= 2;
	}
}

int cmpnode(node *a, node *b, int silazno) 
{
	if ( silazno )	return - a->ocjena + b->ocjena;
	else return  a->ocjena - b->ocjena;
}

void udaljenost( int depth, atom **lu, int fl[dulj+1], int str)
{
	atom *li = NULL;
	int i;
	if ( depth == 1)
	{
		for ( i = 0; i < 7; i++) 	if ( !fl[ stranica[str][i] ])
		{
			dodaj( lu, stranica[str][i]);udmall++;
			fl[ stranica[str][i] ] = 1;
		}
		
 
	}
	atom *it = *lu;

	while ( it != NULL )
	{
		ud[it->ind][str] = depth;
		for ( i = 0; i < 6; i++ )
		/*if ((b[it->ind].s[i]) && !(b[b[it->ind].s[i]].igrac) && !(b[b[it->ind].s[i]].protivnik) && !fl[b[it->ind].s[i]]) 
		{
			dodaj ( &li, b[it->ind].s[i]);
			fl[ b[it->ind].s[i] ] = 1;
		}*/
		if ((fb[it->ind].s[i]) && !(b[fb[it->ind].s[i]].protivnik) && !fl[fb[it->ind].s[i]] && 
		!b[fb[it->ind].kl[i]].igrac && !b[fb[it->ind].kl[i]].protivnik &&
		!b[fb[it->ind].kl[i+6]].igrac && !b[fb[it->ind].kl[i+6]].protivnik)
		{
		/*if (b[it->ind].s[i] == 87) {
			printf("igrac %d itind  %d susj %d dep %d\n", b[b[it->ind].s[i]].igrac, it->ind, b[it->ind].s[i], depth);
			Ispisi(igrac);
					}*/
			if (!b[fb[it->ind].s[i]].igrac)
			{
				//printf("itind  %d susj %d dep %d\n", it->ind, b[it->ind].s[i], depth);
				dodaj ( &li, fb[it->ind].s[i]);	udmall++;
				fl[ fb[it->ind].s[i] ] = 1;
				fl[ fb[it->ind].kl[i] ] = 1;
				fl[ fb[it->ind].kl[i+6] ] = 1;
				ud[fb[it->ind].kl[i]][str] = depth+1;
				ud[fb[it->ind].kl[i+6]][str] = depth+1;
			}
			else  
			{
				//printf("itind  %d susj %d dep %d ud %d\n", it->ind, b[it->ind].s[i], depth,ud[b[it->ind].s[i]][str]);
				if ( ud[fb[it->ind].s[i]][str] > depth)	ud[fb[it->ind].s[i]][str] = depth;
				
			}	
		}
		else if ((b[it->ind].s[i]) &&   !(b[b[it->ind].s[i]].protivnik) && !fl[b[it->ind].s[i]]) 
		{
		/*if (b[it->ind].s[i] == 87) {
			printf("igrac %d itind  %d susj %d dep %d\n", b[b[it->ind].s[i]].igrac, it->ind, b[it->ind].s[i], depth);
			Ispisi(igrac);
					}*/
			if (!b[b[it->ind].s[i]].igrac)
			{
				//printf("itind  %d susj %d dep %d\n", it->ind, b[it->ind].s[i], depth);
				dodaj ( &li, b[it->ind].s[i]);	udmall++;
				fl[ b[it->ind].s[i] ] = 1;
			}
			else  
			{
				//printf("itind  %d susj %d dep %d ud %d\n", it->ind, b[it->ind].s[i], depth,ud[b[it->ind].s[i]][str]);
				if ( ud[b[it->ind].s[i]][str] > depth)	ud[b[it->ind].s[i]][str] = depth;
				
			}
		}
		it = it->next;
	}
	if ( (li != NULL) || (depth == 0)) udaljenost( depth + 1, &li, fl, str);
	udfree += obrisiniz( &li);
}

void racunajudaljenost( pozicija **p, int trazenastranica)
{
	atom *ls3 = NULL;
	atom *kam;
	klaster *k;
	skupina *it;
	int i;
	for ( i = 1; i < 107; i++) ud[i][trazenastranica] = 100;
	//namjestib( igrac, protivnik); // moze se zvati negdje drugdje radi ponavljanja
	//for ( i = 1; i < 107; i++) fl[i] = ((b[i].igrac) || (b[i].protivnik));
	for ( i = 1; i < 107; i++) fl[i] = ((b[i].protivnik));
	it = (*p)->igracskupine;
	while ( it != NULL)
	{
		k = it->forsirani;
	while ( k != NULL)
	{
		kam = k->grupa;
		while ( kam != NULL)
		{
			fl[kam->ind] = 1;
			kam = kam->next;
		}
		k = k->next;
	}
		it = it->next;
	}
	it = (*p)->protivnikskupine;
	while ( it != NULL)
	{
		k = it->forsirani;
	while ( k != NULL)
	{
		kam = k->grupa;
		while ( kam != NULL)
		{
			fl[kam->ind] = 1;
			kam = kam->next;
		}
		k = k->next;
	}
		it = it->next;
	}

	it = (*p)->igracskupine;
	while ( it != NULL)
	{
				//printf("skupina %d, brk. %d, brstr. %d, brvrh. %d: ", i, it->brojkamenja, it->brstr, it->brvrh);

		if ( it->str[trazenastranica] ) 
		{
			kam = it->nizkamen;
			while ( kam != NULL )
			{
				dodaj( &ls3, kam->ind);	udmall++;
				fl[kam->ind] = 1;
				kam = kam->next;
			}
		}
		it = it->next;
	}
	udaljenost( 0, &ls3, fl, trazenastranica);
	udfree += obrisiniz( &ls3);
}

void udaljenostp( int depth, atom **lu, int fl[dulj+1], int str)
{
	atom *li = NULL;
	int i;
	if ( depth == 1)
	{
		for ( i = 0; i < 7; i++) 	if ( !fl[ stranica[str][i] ])
		{
			dodaj( lu, stranica[str][i]);
			fl[ stranica[str][i] ] = 1;
		}
		
 
	}
	atom *it = *lu;
	while ( it != NULL )
	{
		up[it->ind][str] = depth;
		for ( i = 0; i < 6; i++ )
		/*if ((b[it->ind].s[i]) && !(b[b[it->ind].s[i]].igrac) && !(b[b[it->ind].s[i]].protivnik) && !fl[b[it->ind].s[i]]) 
		{
			dodaj ( &li, b[it->ind].s[i]);
			fl[ b[it->ind].s[i] ] = 1;
		}*/
		if ((fb[it->ind].s[i]) && !(b[fb[it->ind].s[i]].igrac) && !fl[fb[it->ind].s[i]] && 
		!b[fb[it->ind].kl[i]].igrac && !b[fb[it->ind].kl[i]].protivnik &&
		!b[fb[it->ind].kl[i+6]].igrac && !b[fb[it->ind].kl[i+6]].protivnik)
		{
		/*if (b[it->ind].s[i] == 87) {
			printf("igrac %d itind  %d susj %d dep %d\n", b[b[it->ind].s[i]].igrac, it->ind, b[it->ind].s[i], depth);
			Ispisi(igrac);
					}*/
			if (!b[fb[it->ind].s[i]].protivnik)
			{
				//printf("itind  %d susj %d dep %d\n", it->ind, b[it->ind].s[i], depth);
				dodaj ( &li, fb[it->ind].s[i]);	udmall++;
				fl[ fb[it->ind].s[i] ] = 1;
				fl[ fb[it->ind].kl[i] ] = 1;
				fl[ fb[it->ind].kl[i+6] ] = 1;
				up[fb[it->ind].kl[i]][str] = depth+1;
				up[fb[it->ind].kl[i+6]][str] = depth+1;
			}
			else  
			{
				//printf("itind  %d susj %d dep %d ud %d\n", it->ind, b[it->ind].s[i], depth,ud[b[it->ind].s[i]][str]);
				if ( up[fb[it->ind].s[i]][str] > depth)	up[fb[it->ind].s[i]][str] = depth;
				
			}	
		}
		else if ((b[it->ind].s[i]) &&   !(b[b[it->ind].s[i]].igrac) && !fl[b[it->ind].s[i]]) 
		//if (b[it->ind].s[i] == 68) printf("igrac %d itind  %d susj %d dep %d\n", b[b[it->ind].s[i]].igrac, it->ind, b[it->ind].s[i], depth);
		if (!b[b[it->ind].s[i]].protivnik)
		{
			//printf("itind  %d susj %d dep %d\n", it->ind, b[it->ind].s[i], depth);
			dodaj ( &li, b[it->ind].s[i]);
			fl[ b[it->ind].s[i] ] = 1;
		}
		else  
		{
			//printf("itind  %d susj %d dep %d up %d\n", it->ind, b[it->ind].s[i], depth,up[b[it->ind].s[i]][str]);
			if ( up[b[it->ind].s[i]][str] > depth)	up[b[it->ind].s[i]][str] = depth;
			
		}
		it = it->next;
	}
	if ( (li != NULL) || (depth == 0)) udaljenostp( depth + 1, &li, fl, str);
	obrisiniz( &li);
}

void racunajudaljenostp( pozicija **p, int trazenastranica)
{
	atom *ls3 = NULL;
	atom *kam;
	skupina *it;
	klaster *k;
	int i;
	for ( i = 1; i < 107; i++) up[i][trazenastranica] = 100;
	//namjestib( igrac, protivnik); // moze se zvati negdje drugdje radi ponavljanja
	//for ( i = 1; i < 107; i++) fl[i] = ((b[i].igrac) || (b[i].protivnik));
	for ( i = 1; i < 107; i++) fl[i] = ((b[i].igrac));
	it = (*p)->igracskupine;
	while ( it != NULL)
	{
		k = it->forsirani;
	while ( k != NULL)
	{
		kam = k->grupa;
		while ( kam != NULL)
		{
			fl[kam->ind] = 1;
			kam = kam->next;
		}
		k = k->next;
	}
		it = it->next;
	}
	it = (*p)->protivnikskupine;
	while ( it != NULL)
	{
		k = it->forsirani;
	while ( k != NULL)
	{
		kam = k->grupa;
		while ( kam != NULL)
		{
			fl[kam->ind] = 1;
			kam = kam->next;
		}
		k = k->next;
	}
		it = it->next;
	}

	it = (*p)->protivnikskupine;
	while ( it != NULL)
	{
				//printf("skupina %d, brk. %d, brstr. %d, brvrh. %d: ", i, it->brojkamenja, it->brstr, it->brvrh);

		if ( it->str[trazenastranica] ) 
		{
			kam = it->nizkamen;
			while ( kam != NULL )
			{
				dodaj( &ls3, kam->ind);
				fl[kam->ind] = 1;
				kam = kam->next;
			}
		}
		it = it->next;
	}
	udaljenostp( 0, &ls3, fl, trazenastranica);
	obrisiniz( &ls3);
}

int dostr(pozicija **arg)
{
	//igrac
	skupina *it = (*arg)->igracskupine ;
	atom *kam;
	int m = 0, i, v=0, vp=0;
		//for ( i = 0; i < 5; i++) (*arg)->str[i] = 100;
	while ( it != NULL ) 
	{
		if ( m < it->brstr) m = it->brstr;
		kam = it->nizkamen;
		for ( i = 0; i < 6; i++) it->str[i] = 100;
		for ( i = 0; i < 4; i++) it->mstr[i] = 5;
		while ( kam != NULL)
		{
			for ( i = 0; i < 5; i++) if ( ud[kam->ind][i] < it->str[i] )	it->str[i] = ud[kam->ind][i];
			kam = kam->next;
		}
		for ( i = 0; i < 5; i++) 
		{
			//if ( (*arg)->str[i] > it->str[i] )	(*arg)->str[i] = it->str[i];
			if (it->str[it->mstr[0]] > it->str[i])
			{
				it->mstr[3] = it->mstr[2];
				it->mstr[2] = it->mstr[1];
				it->mstr[1] = it->mstr[0];
				it->mstr[0] = i;
			}
			else if (it->str[it->mstr[1]] > it->str[i])
			{
				it->mstr[3] = it->mstr[2];
				it->mstr[2] = it->mstr[1];
				it->mstr[1] = i;
			}
			else if (it->str[it->mstr[2]] > it->str[i])
			{
				it->mstr[3] = it->mstr[2];
				it->mstr[2] = i;
			}
			else if (it->str[it->mstr[3]] > it->str[i])	it->mstr[3] = i;
		}
		//it->value = - it->str[it->mstr[0]] - it->str[it->mstr[1]] - it->str[it->mstr[2]]- it->str[it->mstr[3]] ;
		//it->value = - it->str[it->mstr[0]] - it->str[it->mstr[1]] - it->str[it->mstr[2]];
		for ( i = 0; i < 5; i++) if (it->str[i] != 100) it->value -= it->str[i]; else it->value -= 13;
		
		if (it->value < -cutoff)  it->value = -cutoff;
		v -= it->value;
		it = it->next;		
	}
	//printf(" mstr %d\n", m);

	(*arg)->mbrstr = m;
	m = 0;
	it = (*arg)->protivnikskupine ;
	while ( it != NULL ) 
	{
		if ( m < it->brstr) m = it->brstr;
		kam = it->nizkamen;
		for ( i = 0; i < 6; i++) it->str[i] = 100;
		for ( i = 0; i < 4; i++) it->mstr[i] = 5;
		while ( kam != NULL)
		{
			for ( i = 0; i < 5; i++) if ( up[kam->ind][i] < it->str[i] )	it->str[i] = up[kam->ind][i];
			kam = kam->next;
		}
		for ( i = 0; i < 5; i++) 
		{
			//if ( (*arg)->str[i] > it->str[i] )	(*arg)->str[i] = it->str[i];
			if (it->str[it->mstr[0]] > it->str[i])
			{
				it->mstr[3] = it->mstr[2];
				it->mstr[2] = it->mstr[1];
				it->mstr[1] = it->mstr[0];
				it->mstr[0] = i;
			}
			else if (it->str[it->mstr[1]] > it->str[i])
			{
				it->mstr[3] = it->mstr[2];
				it->mstr[2] = it->mstr[1];
				it->mstr[1] = i;
			}
			else if (it->str[it->mstr[2]] > it->str[i])
			{
				it->mstr[3] = it->mstr[2];
				it->mstr[2] = i;
			}
			else if (it->str[it->mstr[3]] > it->str[i])	it->mstr[3] = i;
		}
		//it->value = - it->str[it->mstr[0]] - it->str[it->mstr[1]] - it->str[it->mstr[2]] - it->str[it->mstr[3]];
		//it->value = - it->str[it->mstr[0]] - it->str[it->mstr[1]] - it->str[it->mstr[2]];
		for ( i = 0; i < 5; i++) if (it->str[i] != 100) it->value -= it->str[i]; else it->value -= 13;
		if (it->value < -cutoff)  it->value = -cutoff;
		
		vp -= it->value;
		
		
		it = it->next;		
	}
	(*arg)->pbrstr = m;

	if ((*arg)->ivrh[0] > 2)	
	{
		(*arg)->ocjena = WIN+1;
		return;
	}
	if ((*arg)->pvrh[0] > 2)	
	{
		(*arg)->ocjena = -WIN-1;
		return;
	}
	(*arg)->ocjena = 
	4000*fact( (*arg)->ivrh[0])+0*(*arg)->lanacigrac + 0*fact((*arg)->mbrstr) - 1*v -
	4000*fact( (*arg)->pvrh[0])-0*(*arg)->lanacprotivnik - 0*fact((*arg)->pbrstr) + 1*vp;

}


int dokorijen( atom **niz, node *arg, int p)
{
		int i = 1;
	if ((arg->parent == NULL) || 1) {
		Ispisi( *niz);
		printf("p:%d potez %d\n,", p, arg->potez);
		}
	else 
	{
		//obrisiniz( niz);
	//atom *list = NULL;
		//dodaj( niz, p);
	}
	/*while (arg->parent != NULL)
	{
		i++;
		dodaj( niz, arg->potez);
		arg = arg->parent;
	}
	//printf("n/");
	//Ispisi( *niz);*/
	return i; 
}

node *nadjipotez( node *arg)
{
	node *max;
	if (( arg == NULL) || ( arg->firstchild == NULL))	return NULL;
	max = arg->firstchild;
	printf(" potez %d ocjena %d\n", max->potez, max->ocjena); 
	arg = max->sibling;
	while ( arg != NULL)
	{
		printf(" potez %d ocjena %d\n", arg->potez, arg->ocjena); 
		if ( arg->ocjena > max->ocjena) max = arg;
		arg = arg->sibling; 
	}
	return max;
}

int fact( int n)
{
	switch (n)
	{
		case 0: return 0;
		case 1: return 1;
		case 2: return 3;//ovisi o6 treba stavit define za vrijednosti
		default: return 6;
	}
} 

int obrisiniz( atom **niz) //brise ali ne ne postavlja pokazivac prethodnog NULL
{
	atom *p;
	int c = 0;
	while (*niz != NULL) 
	{
		p = *niz;
		*niz = (*niz)->next;
		//printf("afree %d\n", p->ind);	
	
		free( p);
		c++;
		afree++;
	}
	return c;
}

void obrisiskupine( skupina **sk)
{
	skupina *s;
	while (*sk != NULL)
	{
		obrisiniz ( &(*sk)->nizkamen);
		obrisiklasterniz( &(*sk)->forsirani);
		s = *sk;
		*sk = (*sk)->next;
		free( s);	
	}
}

int setpozicija( pozicija **arg, atom *igracset, atom *protivnikset )
{	
	//pozicija *novi = malloc( sizeof(pozicija) );
	//obrisiniz( &(*arg)->potezi);
	obrisiniz( &(*arg)->igrac);
	obrisiniz( &(*arg)->protivnik);
	obrisiskupine( &(*arg)->igracskupine);
	obrisiskupine( &(*arg)->protivnikskupine);
	
	(*arg)->igrac = kopirajniz( igracset );
	(*arg)->protivnik = kopirajniz( protivnikset );
	namjestib( igracset, protivnikset);// namjesta igrac i protivnik
	skupineigrac( arg );
	skupineprotivnik( arg );
	rubniklaster( *arg);
	pregledajskupine( (*arg)->igracskupine, &((*arg)->lanacigrac), (*arg)->ivrh);
	pregledajskupine( (*arg)->protivnikskupine, &((*arg)->lanacprotivnik), (*arg)->pvrh);
	racunajudaljenost( arg, 0);
	racunajudaljenost( arg, 1);
	racunajudaljenost( arg, 2);
	racunajudaljenost( arg, 3);
	racunajudaljenost( arg, 4);
	racunajudaljenostp( arg, 0);
	racunajudaljenostp( arg, 1);
	racunajudaljenostp( arg, 2);
	racunajudaljenostp( arg, 3);
	racunajudaljenostp( arg, 4);/**/
	/*if (moves <= vrh_off)
{
	 vrhudaljenost();
}*/
	dostr( arg);
	//(*arg)->potezi = generirajpoteze( *arg);

	//printf(" mstr %d", (*arg)->mbrstr);
	//printf(" pstr %d", (*arg)->pbrstr);
	/*(*arg)->brvrhovaigrac = pregledajskupine( (*arg)->igracskupine );
	(*arg)->brvrhovaprotivnik = pregledajskupine( (*arg)->protivnikskupine );*/

	//novi->igracskupine=NULL;

	//!!!!!!!!!!!!!!odabir scora
	//(*arg)->ocjena = fact( (*arg)->brvrhovaigrac) - fact( (*arg)->brvrhovaprotivnik);
	//novi->protivnikskupine=NULL;
	return (*arg)->ocjena;
}

int alfabetak( node **arg, int dubina, int alfa, int beta, atom *igracset, atom *protivnikset, pozicija **pz, int player, int *izbor)
{
	if (! dubina)	
	{
		pi++;
		int sp = setpozicija( pz, igracset, protivnikset);
		(*arg)->ocjena = sp;
		/*if ( ((*arg)->potez == 24) && ((*arg)->parent->potez == 9) && ((*arg)->parent->parent->potez == 23)) 
		{
			printf("pz->ocjena %d\n", (*pz)->ocjena);
			ispisipotez( *arg);
			ispisipoziciju( **pz);
		}*/
		return sp;
		
	}
	if (*arg == NULL) *arg = novinode( arg, 0);
	setpozicija( pz, igracset, protivnikset);
	//atom *potez = (*pz)->potezi;
	kandidat *opcije = generirajkandidate( *pz); 
	atom *potez = a_l_k( opcije);
	atom *pp = potez;
	node *it;
	if (  player)
	{
				//Ispisi(pp);
		int p;
		int ab;
		while ( potez != NULL)
		{	
			node *child = novinode( arg, potez->ind);
			p = potez->ind;
			potez = potez->next;
//			ubaci( &igracset, izbaci( &(*pz)->potezi, p));
			ubaci( &igracset, izbaci( &pp, p));
			ab = alfabetag( &child, dubina - 1, alfa, beta, igracset, protivnikset, pz, 0, izbor);
			(*arg)->ocjena = (*arg)->ocjena ^ (((*arg)->ocjena ^ child->ocjena) & -((*arg)->ocjena < child->ocjena));//max

			//(*arg)->ocjena = ab;
			if (ab > alfa) 
					//printf("p: %d, ", p);
					//Ispisi(igrac);
					if ((*arg)->potez == 0)  {
									if ( verbose )	printf ("IGRAM : %d\n" ,p);
									if ( verbose )	
									printf ("ab %d alfa %d\n", ab, alfa);
									*izbor = p;
									//*exp1 = ab;
					//dokorijen( &parent, *arg, p);
					}
			obrisi( izbaci( &igracset, p));
			alfa = alfa ^ ((alfa ^ ab) & -(alfa < ab));//max
			//if (ab <= beta)	return beta;
			//alfa = r;
			if ( beta <= alfa)	
			{	
				(*arg)->ocjena = +intmax;
				break;
			}
		}
		obrisiniz( &pp);
			/*r = -32000;
			it = (*arg)->firstchild;
			while (it)
			{
							r = r ^ ((r ^ it->ocjena) & -(r < it->ocjena));//max
				it = it->sibling;

			}
			(*arg)->ocjena =r;*/
		return alfa;
	}			
	else 
	{
		int p;
		int ab;
		while ( potez != NULL)
		{
			node *child = novinode( arg, potez->ind);
			p = potez->ind;
			potez = potez->next;
			ubaci( &protivnikset, izbaci( &pp, p));
			ab = alfabetag( &child, dubina - 1, alfa, beta, igracset, protivnikset, pz, 1, izbor);
			(*arg)->ocjena = child->ocjena ^ (((*arg)->ocjena ^ child->ocjena) & -((*arg)->ocjena < child->ocjena));//min
			//(*arg)->ocjena = ab;
			//if (ab < beta)	if ((*arg)->potez == 1) *pizb = p;
			obrisi( izbaci( &protivnikset, p));
			beta = ab ^ ((beta ^ ab) & -(beta < ab)); //min
			//if ( (p == 16) && ( dubina == 2) && ((*arg)->potez == 22))
			if ( alfa >= beta) 
			{
				(*arg)->ocjena = -intmax;
				break;
			}
		}
		obrisiniz( &pp);
			/*r = +32000;
			it = (*arg)->firstchild;
			while (it)
			{
							r = it->ocjena ^ ((r ^ it->ocjena) & -(r < it->ocjena));//min
				it = it->sibling;

			}
			(*arg)->ocjena =r;*/
		return beta;
	}
}

int alfabetan( int dubina, int alfa, int beta, atom *igrac, atom *protivnik, pozicija **pz, int player, int *izbor)
{
	if (! dubina)	
	{
		pi++;
		int sp = setpozicija( pz, igrac, protivnik);
		//(*arg)->ocjena = sp;
		//printf("racunam poziciju %d., dubina: %d, ocjena %d\n", pi, dubina, sp);
		//ispisipoziciju( **pz);
		return sp;
		
	}
	//if (*arg == NULL) *arg = novinode( arg, 0);
	//atom *potez = kandidati( pz, igrac, protivnik); 
	atom *potez = listasusjeda( igrac, protivnik); 
	//atom * potez = noviatom( 1);

	//printf("potez %d dub %d\n", (*arg)->potez, dubina);
	//printf("ablista poteza: ");
	//Ispisi( potez);	
	atom *pp = potez;
	//int igra = dubina % 2;
				//printf( "/dubina	%d arg->ind	%d\n", dubina, (*arg)->potez);
	if (  player)
	{
				//Ispisi(pp);
		int p;
		int ab, r;
		while ( potez != NULL)
		{	
			//node *child = novinode( arg, potez->ind);
			p = potez->ind;
			potez = potez->next;
				//printf(" potez %d\n", p);
			
			//printf(" igra %d\n", igra);
			ubaci( &igrac, izbaci( &pp, p));
			/*printf(" pz igrac:");
			Ispisi(igrac);
			printf(" pz protivnik:");
			Ispisi(protivnik);*/
			//mlist dodaj potez ind
			ab = alfabetan( dubina - 1, alfa, beta, igrac, protivnik, pz, 0, izbor);
			//(*arg)->alfa = ab;
			if (ab > alfa) 
					//printf("p: %d, ", p);
					//Ispisi(igrac);
					//if ((*arg)->potez == 0)  
					{
									//printf ("IGRAM : %d\n" ,p);
									*izbor = p;
									//*exp1 = ab;
					//dokorijen( &parent, *arg, p);
					}
			//izbaci( &plista, p)
			obrisi( izbaci( &igrac, p));
			alfa = alfa ^ ((alfa ^ ab) & -(alfa < ab));//max
			//if (ab <= beta)	return beta;
			//(*arg)->alfa = ab;
			//alfa = r;
			if ( beta <= alfa)	
			{
				break;
			}
		}
	obrisiniz( &pp);
			return alfa;
	}			
	else 
	{
		int p;
		int ab, r;
		while ( potez != NULL)
		{
			//node *child = novinode( arg, potez->ind);
			p = potez->ind;
			potez = potez->next;
			//printf(" protivnik %d\n", igra);
			ubaci( &protivnik, izbaci( &pp, p));
			ab = alfabetan( dubina - 1, alfa, beta, igrac, protivnik, pz, 1, izbor);
			//if (ab < beta)	if ((*arg)->potez == 1) *pizb = p;
			obrisi( izbaci( &protivnik, p));
			beta = ab ^ ((beta ^ ab) & -(beta < ab)); //min
			if ( alfa >= beta) 
			{
				break;
			}

		}
	obrisiniz( &pp);
			return beta;
	//return dubina1.kor;
	}
			//obrisinode( *arg);

}

int alfabeta( node **arg, int dubina, int alfa, int beta, atom *igracset, atom *protivnikset, pozicija **pz, int player, int *izbor)
{
	if (! dubina)	
	{
		pi++;
		int sp = setpozicija( pz, igracset, protivnikset);
		(*arg)->ocjena = sp;
		/*if ( ((*arg)->potez == 24) && ((*arg)->parent->potez == 9) && ((*arg)->parent->parent->potez == 23)) 
		{
			printf("pz->ocjena %d\n", (*pz)->ocjena);
			ispisipotez( *arg);
			ispisipoziciju( **pz);
		}*/
		return sp;
		
	}
	if (*arg == NULL) *arg = novinode( arg, 0);
	setpozicija( pz, igracset, protivnikset);
	//atom *potez = (*pz)->potezi;
	kandidat *opcije = generirajkandidate( *pz); 
	//sortirajkandidate;

	kandidat *pp = opcije;
	kandidat *k;
	atom *a;
	//node *it;
	if (  player)
	{
				//Ispisi(pp);
		int p;
		int ab;
		while ( opcije != NULL)
		{	
			p = opcije->p->ind;
			node *child = novinode( arg, p);
			opcije = opcije->next;
//			ubaci( &igracset, izbaci( &(*pz)->potezi, p));
			k = izbacikandidat( &pp, p);
			a = k->p;
			obrisikandidat( k);
			ubaci( &igracset, a);
			//ubaci( &igracset, izbaci( &pp, p));
			ab = alfabetak( /*NULL*/&child, dubina - 1, alfa, beta, igracset, protivnikset, pz, 0, izbor);
			(*arg)->ocjena = (*arg)->ocjena ^ (((*arg)->ocjena ^ child->ocjena) & -((*arg)->ocjena < child->ocjena));//max

			//(*arg)->ocjena = ab;
			if (ab > alfa) 
					//printf("p: %d, ", p);
					//Ispisi(igrac);
					if ((*arg)->potez == 0)
			{
									if ( verbose )	printf ("IGRAM : %d\n" ,p);
									if ( verbose )	
									printf ("ab %d alfa %d\n", ab, alfa);
									*izbor = p;
									//*exp1 = ab;
					//dokorijen( &parent, *arg, p);
					}
			obrisi( izbaci( &igracset, p));
			alfa = alfa ^ ((alfa ^ ab) & -(alfa < ab));//max
			//if (ab <= beta)	return beta;
			//alfa = r;
			if ( beta <= alfa)	
			{	
				/*(*arg)->ocjena = +intmax;
				break;*/
			}
		}
		obrisikandidate( &pp);
			/*r = -32000;
			it = (*arg)->firstchild;
			while (it)
			{
							r = r ^ ((r ^ it->ocjena) & -(r < it->ocjena));//max
				it = it->sibling;

			}
			(*arg)->ocjena =r;*/
		return alfa;
	}			
	else 
	{
		int p;
		int ab;
		while ( opcije != NULL)
		{
			node *child = novinode( arg, opcije->p->ind);
			p = opcije->p->ind;
			opcije = opcije->next;
			k = izbacikandidat( &pp, p);
			a = k->p;
			obrisikandidat( k);
			ubaci( &igracset, a);
			ab = alfabetak( /*NULL*/&child, dubina - 1, alfa, beta, igracset, protivnikset, pz, 1, izbor);
			(*arg)->ocjena = child->ocjena^ (((*arg)->ocjena ^ child->ocjena) & -((*arg)->ocjena < child->ocjena));//min
			//(*arg)->ocjena = ab;
			//if (ab < beta)	if ((*arg)->potez == 1) *pizb = p;
			obrisi( izbaci( &protivnikset, p));
			beta = ab ^ ((beta ^ ab) & -(beta < ab)); //min
			//if ( (p == 16) && ( dubina == 2) && ((*arg)->potez == 22))
			if ( alfa >= beta) 
			{
				/*(*arg)->ocjena = -intmax;
				break;*/
			}
		}
		obrisikandidate( &pp);
			/*r = +32000;
			it = (*arg)->firstchild;
			while (it)
			{
							r = it->ocjena ^ ((r ^ it->ocjena) & -(r < it->ocjena));//min
				it = it->sibling;

			}
			(*arg)->ocjena =r;*/
		return beta;
	}
}

int alfabetag( node **arg, int dubina, int alfa, int beta, atom *igracset, atom *protivnikset, pozicija **pz, int player, int *izbor)
{
	if (! dubina)	
	{
		pi++;
		int sp = setpozicija( pz, igracset, protivnikset);
		(*arg)->ocjena = sp;
		/*if ( ((*arg)->potez == 24) && ((*arg)->parent->potez == 9) && ((*arg)->parent->parent->potez == 23)) 
		{
			printf("pz->ocjena %d\n", (*pz)->ocjena);
			ispisipotez( *arg);
			ispisipoziciju( **pz);
		}*/
		return sp;
		
	}
	if (*arg == NULL) *arg = novinode( arg, 0);
	setpozicija( pz, igracset, protivnikset);
	//atom *potez = (*pz)->potezi;
	atom *potez = generirajpoteze( *pz); 
	atom *pp = potez;
	node *it;
	if (  player)
	{
				//Ispisi(pp);
		int p;
		int ab;
		while ( potez != NULL)
		{	
			node *child = novinode( arg, potez->ind);
			p = potez->ind;
			potez = potez->next;
//			ubaci( &igracset, izbaci( &(*pz)->potezi, p));
			ubaci( &igracset, izbaci( &pp, p));
			ab = alfabetag( &child, dubina - 1, alfa, beta, igracset, protivnikset, pz, 0, izbor);
			(*arg)->ocjena = (*arg)->ocjena ^ (((*arg)->ocjena ^ child->ocjena) & -((*arg)->ocjena < child->ocjena));//max

			//(*arg)->ocjena = ab;
			if (ab > alfa) 
					//printf("p: %d, ", p);
					//Ispisi(igrac);
					if ((*arg)->potez == 0)  {
									if ( verbose )	printf ("IGRAM : %d\n" ,p);
									if ( verbose )	
									printf ("ab %d alfa %d\n", ab, alfa);
									*izbor = p;
									//*exp1 = ab;
					//dokorijen( &parent, *arg, p);
					}
			obrisi( izbaci( &igracset, p));
			alfa = alfa ^ ((alfa ^ ab) & -(alfa < ab));//max
			//if (ab <= beta)	return beta;
			//alfa = r;
			if ( beta <= alfa)	
			{	
				(*arg)->ocjena = +intmax;
				break;
			}
		}
		obrisiniz( &pp);
			/*r = -32000;
			it = (*arg)->firstchild;
			while (it)
			{
							r = r ^ ((r ^ it->ocjena) & -(r < it->ocjena));//max
				it = it->sibling;

			}
			(*arg)->ocjena =r;*/
		return alfa;
	}			
	else 
	{
		int p;
		int ab;
		while ( potez != NULL)
		{
			node *child = novinode( arg, potez->ind);
			p = potez->ind;
			potez = potez->next;
			ubaci( &protivnikset, izbaci( &pp, p));
			ab = alfabetag( &child, dubina - 1, alfa, beta, igracset, protivnikset, pz, 1, izbor);
			(*arg)->ocjena = child->ocjena ^ (((*arg)->ocjena ^ child->ocjena) & -((*arg)->ocjena < child->ocjena));//min
			//(*arg)->ocjena = ab;
			//if (ab < beta)	if ((*arg)->potez == 1) *pizb = p;
			obrisi( izbaci( &protivnikset, p));
			beta = ab ^ ((beta ^ ab) & -(beta < ab)); //min
			//if ( (p == 16) && ( dubina == 2) && ((*arg)->potez == 22))
			if ( alfa >= beta) 
			{
				(*arg)->ocjena = -intmax;
				break;
			}
		}
		obrisiniz( &pp);
			/*r = +32000;
			it = (*arg)->firstchild;
			while (it)
			{
							r = it->ocjena ^ ((r ^ it->ocjena) & -(r < it->ocjena));//min
				it = it->sibling;

			}
			(*arg)->ocjena =r;*/
		return beta;
	}
}

void obrisi( atom *arg)
{
	//printf("afree %d\n", arg->ind);	
	free( arg);
	afree++;
}



node *kreirajstablo( int dubina, node **arg, atom *igrac, atom *protivnik)
{
	if (! dubina)	{ return NULL;}
	if (*arg == NULL) *arg = novinode( arg, 0);
	atom *potez = listasusjeda( igrac, protivnik); 
	atom *pp = potez;
				//printf( "/dubina	%d arg->ind	%d\n", dubina, (*arg)->potez);
				//Ispisi(pp);
	int p;
	while ( potez != NULL)
	{
		node *child = novinode( arg, potez->ind);
		p = potez->ind;
		potez = potez->next;
		if ((*arg)->odigrao)
		{
			ubaci( &protivnik, izbaci( &pp, p));
			kreirajstablo( dubina - 1, &child, igrac, protivnik);
			obrisi( izbaci( &protivnik, p));
		}
		else 
		{
			ubaci( &igrac, izbaci( &pp, p));
			kreirajstablo( dubina - 1, &child, igrac, protivnik);
			obrisi( izbaci( &igrac, p));
		}
	}
	return *arg;
}

skupina *skupind( skupina *arg, int pot)
{
			int itf;
	/*arg = test->igracskupine;
	while ( arg != NULL )
	{*/
		atom *it = arg->nizkamen;
		while ( it != NULL) 
		{
	
//printf("itind %d pot %d\n", it->ind, pot);
			for ( itf = 0; itf < 6; itf++)	
			{
				if ( b[it->ind].s[itf] == pot )
				{ 
			
				return arg;
				
				}
			
			
			}
			/*if ( it->ind == pot ) 
			{
				printf("match itind %d pot %d\n", it->ind, pot);
			}*/
			it = it->next;
		}
		//arg = arg->next;
	//}
	return NULL;
}

atom *kandidati( pozicija **board, atom *igrac, atom *protivnik)
{
	setpozicija( board, igrac, protivnik);//moze lakse
	namjestib( igrac, protivnik);
	atom *lsp = listasusjeda( igrac, protivnik);
atom *ls, *d, *ds = NULL;
	int it, itf, u=1;
	skupina *bskup;
	atom *sit;
	atom *skup;
ls =lsp;
	//printf("ls ");
	//Ispisi( ls);
	while ( ls != NULL )
	{
		int br = 0;
/*		bskup = (*board)->igracskupine;
		while ( bskup != NULL)
		{
			sit = bskup->nizkamen;
			Ispisi(bskup->nizkamen);
			while ( sit != NULL )
			{
				if sit->ind
				printf(" %d", sit->ind);
				sit = sit->next;
			for ( itf = 0; itf < 6; itf++)	
			{
				if ( (b[sit->ind].s[itf] == ls->ind) && (u) )
				{ 
					u = 0;
					return arg;
				
				}
			
			
			}
			}
			bskup = bskup->next;
		}*/
		//bskup = skupind( (*board)->igracskupine , ls->ind);
		//while ( bskup != NULL )	
		
		d=ls->next;
		//if ( bskup != NULL)
		{
		  //Ispisi(bskup->nizkamen);
			namjestib( igrac, protivnik);
			for ( it = 0; it < 6; it++)	
			{
		
				if	((b[ b[ls->ind].s[it]].igrac)	&&	(b[ls->ind].s[it] != 0))
					{ 
					br++;
					}
			
			
			
			}
						//printf("ind:%d br: %d\n", ls->ind, br);
		if	((br == 2) )
					{
						//dvjeskupine();
						ubaci ( &ds, izbaci( &lsp, ls->ind));
					}
					if ( ( br < 1 ) || ( br > 1 ))  
					{
						//printf("susjed 1!\n");
						obrisi( izbaci( &lsp, ls->ind));
					}
					
			//bskup = bskup->next;
		}
		//else SUSJED PROTIVNIK
			
		//else printf(" brsk je null\n");		
		ls = d;
	}
	//if (verbose) printf("2sd:");
	//if (verbose) Ispisi( ds);
	
	//if (verbose) printf("kandidati:");
	//if (verbose) Ispisi( lsp);
	return lsp;
}

kandidat *generirajkandidate( pozicija *p)
{
	kandidat *opcije = NULL;
	skupina	*s;
	klaster	*k;
	atom	*a;
	int	m, f, kl[dulj+1], count=0;
	//init fl
	for ( f = 1; f < 107; f++) kl[f] = 0;
	for ( f = 1; f < 107; f++) fl[f] = 0;
	for ( s = p->igracskupine; s; s = s->next)
	{
		/*if ( s->brstr > 1)
		{
			for ( f = 1; f < 107; f++)
			for ( m = 0; m < 5; m++)
			if ((s-str[m]) && (ud ))	fl[f] = 1;
			
		}*/
		for ( a = s->nizkamen; a; a = a->next)
			fl[a->ind] = 1;
		for ( k = s->forsirani; k; k = k->next)
			if (k->tip)	for ( a = k->grupa; a; a = a->next)
				kl[a->ind] = 1;
			else for ( a = k->grupa; a; a = a->next)
				fl[a->ind] = 1;
	}
	for ( s = p->protivnikskupine; s; s = s->next)
	{
		for ( a = s->nizkamen; a; a = a->next)
			fl[a->ind] = 1;
		for ( k = s->forsirani; k; k = k->next)
			if (k->tip)	for ( a = k->grupa; a; a = a->next)
				kl[a->ind] = 1;
			else for ( a = k->grupa; a; a = a->next)
				fl[a->ind] = 1;
	}

	for ( s = p->igracskupine; s; s = s->next)
	{
		if (s->mstr[2] < 5)  //postoje 3 stranice u dometu
			for ( m = 0; m < 4; m++){
//printf("%d m+1 %d gp %d %d %d %d r%d\n", s->nizkamen->ind,m+1,p->ivrh[m+1] , p->ivrh[(m+1)%5+1] , p->pvrh[m+1] , p->pvrh[m+1]%+1,!(p->ivrh[m+1] || p->ivrh[(m+1)%5+1] || p->pvrh[m+1] || p->pvrh[m+1]%+1));
				//if (!(p->ivrh[m+1] || p->ivrh[(m+1)%5+1] || p->pvrh[m+1] || p->pvrh[m+1]%+1))
		for ( a = s->nizkamen; a; a = a->next)
			{
	//printf("m %d ud[%d][%d]=%d s->str[%d]=%d\n", m, a->ind, s->mstr[m] ,ud[a->ind][s->mstr[m]],s->mstr[m],s->str[s->mstr[m]]);				
				//printf("**");
				if ((ud[a->ind][s->mstr[m]] == s->str[s->mstr[m]]) && (s->str[s->mstr[m]]) && 
					(s->str[s->mstr[m]] != 100))
				{
			//printf("*%d\n",a->ind);
					for ( f = 0; f < 6; f++) { /*if (a->ind == 100)
					printf("%d  %d  %d  %d  %d %d\n", 
fb[a->ind].s[f],(ud[fb[a->ind].s[f]][s->mstr[m]]<=ud[a->ind][s->mstr[m]]),(fl[fb[a->ind].s[f]]),(fl[fb[a->ind].kl[f]]),(fl[fb[a->ind].kl[f+6]]),f);*/

					if ((fb[a->ind].s[f]) && (ud[fb[a->ind].s[f]][s->mstr[m]] <= ud[a->ind][s->mstr[m]]) 
					&& !((fl[fb[a->ind].s[f]]) || (fl[fb[a->ind].kl[f]]) || (fl[fb[a->ind].kl[f+6]])))
					{
						//if (verbose) printf("i2 %d %d\n", fb[a->ind].s[f], a->ind);
						count++;
						dodajkandidat( &opcije, fb[a->ind].s[f], s->value, s->mstr[m], 
						ud[a->ind][s->mstr[m]] - ud[fb[a->ind].s[f]][s->mstr[m]], ud[a->ind][s->mstr[m]], 0);

						fl[fb[a->ind].s[f]] = 1;
						kl[fb[a->ind].kl[f]] = 1;
						kl[fb[a->ind].kl[f+6]] = 1;
					}}						
					for ( f = 0; f < 6; f++)
					if ((fb[a->ind].kl[f]) && (ud[fb[a->ind].kl[f]][s->mstr[m]] <= ud[a->ind][s->mstr[m]]) 
						&& !((kl[fb[a->ind].kl[f]] || fl[fb[a->ind].kl[f]])))
					{
						//if (verbose) printf("i1 %d %d\n", fb[a->ind].kl[f], a->ind);
						count++;
						dodajkandidat( &opcije, fb[a->ind].kl[f], s->value, s->mstr[m], 
						ud[a->ind][s->mstr[m]] - ud[fb[a->ind].s[f]][s->mstr[m]], ud[a->ind][s->mstr[m]], 0);

						fl[fb[a->ind].kl[f]] = 1;	
					}			
								
				}
			}
		}
	}
	//for ( f = 1; f < 107; f++) kl[f] = 0;  //UPITNO DA LI JE POTREBNO??
	for ( s = p->protivnikskupine; s; s = s->next)
	{
		if (s->mstr[2] < 5)
			//if (s->value > -25)
			for ( m = 0; m < 4; m++)
		{
				//if (!(p->ivrh[m+1] || p->ivrh[(m+1)%5+1] || p->pvrh[m+1] || p->pvrh[m+1]%+1))
		for ( a = s->nizkamen; a; a = a->next)
			{
	//printf("m %d ud[%d][%d]=%d s->str[%d]=%d\n", m, a->ind, s->mstr[m] ,ud[a->ind][s->mstr[m]],s->mstr[m],s->str[s->mstr[m]]);
				if (up[a->ind][s->mstr[m]] == s->str[s->mstr[m]] && (s->str[s->mstr[m]]) &&
					(s->str[s->mstr[m]] != 100))
				{
			//printf("*%d\n",a->ind);
					for ( f = 0; f < 6; f++) 
					if ((fb[a->ind].s[f]) && (up[fb[a->ind].s[f]][s->mstr[m]] <= up[a->ind][s->mstr[m]]) 
					&& !((fl[fb[a->ind].s[f]]) || (fl[fb[a->ind].kl[f]]) || (fl[fb[a->ind].kl[f+6]])))
					{
						//if (verbose) printf("p2 %d %d\n", fb[a->ind].s[f], a->ind);
						count++;
						dodajkandidat( &opcije, fb[a->ind].s[f], s->value, s->mstr[m], 
						up[a->ind][s->mstr[m]] - up[fb[a->ind].s[f]][s->mstr[m]], up[a->ind][s->mstr[m]], 10000);


						fl[fb[a->ind].s[f]] = 1;
						kl[fb[a->ind].kl[f]] = 1;
						kl[fb[a->ind].kl[f+6]] = 1;
					}						
					for ( f = 0; f < 6; f++)
					if ((fb[a->ind].kl[f]) && (up[fb[a->ind].kl[f]][s->mstr[m]] <= up[a->ind][s->mstr[m]]) 
						&& !((kl[fb[a->ind].kl[f]] || fl[fb[a->ind].kl[f]])))
					{
						//if (verbose) printf("p1 %d %d\n", fb[a->ind].kl[f], a->ind);
						count++;
						dodajkandidat( &opcije, fb[a->ind].kl[f], s->value, s->mstr[m], 
						up[a->ind][s->mstr[m]] - up[fb[a->ind].s[f]][s->mstr[m]], up[a->ind][s->mstr[m]], 10000);

						fl[fb[a->ind].kl[f]] = 1;	
					}						
				}
			}
		}
	}
	//if (verbose) printf("%d ls: ", count);
	//if (verbose) Ispisi( ls);
		opcije = sortkandidate( opcije, 1);
	
	return opcije;
}


atom *generirajpoteze( pozicija *p)
{
	skupina	*s;
	klaster	*k;
	atom	*a, *ls = NULL;
	int	m, f, kl[dulj+1], count=0;
	//init fl
	for ( f = 1; f < 107; f++) kl[f] = 0;
	for ( f = 1; f < 107; f++) fl[f] = 0;
	for ( s = p->igracskupine; s; s = s->next)
	{
		/*if ( s->brstr > 1)
		{
			for ( f = 1; f < 107; f++)
			for ( m = 0; m < 5; m++)
			if ((s-str[m]) && (ud ))	fl[f] = 1;
			
		}*/
		for ( a = s->nizkamen; a; a = a->next)
			fl[a->ind] = 1;
		for ( k = s->forsirani; k; k = k->next)
			if (k->tip)	for ( a = k->grupa; a; a = a->next)
				kl[a->ind] = 1;
			else for ( a = k->grupa; a; a = a->next)
				fl[a->ind] = 1;
	}
	for ( s = p->protivnikskupine; s; s = s->next)
	{
		for ( a = s->nizkamen; a; a = a->next)
			fl[a->ind] = 1;
		for ( k = s->forsirani; k; k = k->next)
			if (k->tip)	for ( a = k->grupa; a; a = a->next)
				kl[a->ind] = 1;
			else for ( a = k->grupa; a; a = a->next)
				fl[a->ind] = 1;
	}

	for ( s = p->igracskupine; s; s = s->next)
	{
		if (s->mstr[2] < 5)  //postoje 3 stranice u dometu
			for ( m = 0; m < 4; m++){
//printf("%d m+1 %d gp %d %d %d %d r%d\n", s->nizkamen->ind,m+1,p->ivrh[m+1] , p->ivrh[(m+1)%5+1] , p->pvrh[m+1] , p->pvrh[m+1]%+1,!(p->ivrh[m+1] || p->ivrh[(m+1)%5+1] || p->pvrh[m+1] || p->pvrh[m+1]%+1));
				//if (!(p->ivrh[m+1] || p->ivrh[(m+1)%5+1] || p->pvrh[m+1] || p->pvrh[m+1]%+1))
		for ( a = s->nizkamen; a; a = a->next)
			{
	//printf("m %d ud[%d][%d]=%d s->str[%d]=%d\n", m, a->ind, s->mstr[m] ,ud[a->ind][s->mstr[m]],s->mstr[m],s->str[s->mstr[m]]);				
				//printf("**");
				if ((ud[a->ind][s->mstr[m]] == s->str[s->mstr[m]]) && (s->str[s->mstr[m]]) && 
					(s->str[s->mstr[m]] != 100))
				{
			//printf("*%d\n",a->ind);
					for ( f = 0; f < 6; f++) { /*if (a->ind == 100)
					printf("%d  %d  %d  %d  %d %d\n", 
fb[a->ind].s[f],(ud[fb[a->ind].s[f]][s->mstr[m]]<=ud[a->ind][s->mstr[m]]),(fl[fb[a->ind].s[f]]),(fl[fb[a->ind].kl[f]]),(fl[fb[a->ind].kl[f+6]]),f);*/

					if ((fb[a->ind].s[f]) && (ud[fb[a->ind].s[f]][s->mstr[m]] <= ud[a->ind][s->mstr[m]]) 
					&& !((fl[fb[a->ind].s[f]]) || (fl[fb[a->ind].kl[f]]) || (fl[fb[a->ind].kl[f+6]])))
					{
						//if (verbose) printf("i2 %d %d\n", fb[a->ind].s[f], a->ind);
						count++;
						dodaj( &ls, fb[a->ind].s[f]);
						fl[fb[a->ind].s[f]] = 1;
						kl[fb[a->ind].kl[f]] = 1;
						kl[fb[a->ind].kl[f+6]] = 1;
					}						
					else if ((fb[a->ind].kl[f]) && (ud[fb[a->ind].kl[f]][s->mstr[m]] <= ud[a->ind][s->mstr[m]]) 
						&& !((kl[fb[a->ind].kl[f]] || fl[fb[a->ind].kl[f]])))
					{
						//if (verbose) printf("i1 %d %d\n", fb[a->ind].kl[f], a->ind);
						count++;
						dodaj( &ls, fb[a->ind].kl[f]);
						fl[fb[a->ind].kl[f]] = 1;	
					}			
					}			
				}
			}
		}
	}
	//for ( f = 1; f < 107; f++) kl[f] = 0;  //UPITNO DA LI JE POTREBNO??
	for ( s = p->protivnikskupine; s; s = s->next)
	{
		if (s->mstr[2] < 5)
			//if (s->value > -25)
			for ( m = 0; m < 4; m++)
		{
				//if (!(p->ivrh[m+1] || p->ivrh[(m+1)%5+1] || p->pvrh[m+1] || p->pvrh[m+1]%+1))
		for ( a = s->nizkamen; a; a = a->next)
			{
	//printf("m %d ud[%d][%d]=%d s->str[%d]=%d\n", m, a->ind, s->mstr[m] ,ud[a->ind][s->mstr[m]],s->mstr[m],s->str[s->mstr[m]]);
				if (up[a->ind][s->mstr[m]] == s->str[s->mstr[m]] && (s->str[s->mstr[m]]) &&
					(s->str[s->mstr[m]] != 100))
				{
			//printf("*%d\n",a->ind);
					for ( f = 0; f < 6; f++) 
					if ((fb[a->ind].s[f]) && (up[fb[a->ind].s[f]][s->mstr[m]] <= up[a->ind][s->mstr[m]]) 
					&& !((fl[fb[a->ind].s[f]]) || (fl[fb[a->ind].kl[f]]) || (fl[fb[a->ind].kl[f+6]])))
					{
						//if (verbose) printf("p2 %d %d\n", fb[a->ind].s[f], a->ind);
						count++;
						dodaj( &ls, fb[a->ind].s[f]);
						fl[fb[a->ind].s[f]] = 1;
						kl[fb[a->ind].kl[f]] = 1;
						kl[fb[a->ind].kl[f+6]] = 1;
					}						
					else if ((fb[a->ind].kl[f]) && (up[fb[a->ind].kl[f]][s->mstr[m]] <= up[a->ind][s->mstr[m]]) 
						&& !((kl[fb[a->ind].kl[f]] || fl[fb[a->ind].kl[f]])))
					{
						//if (verbose) printf("p1 %d %d\n", fb[a->ind].kl[f], a->ind);
						count++;
						dodaj( &ls, fb[a->ind].kl[f]);
						fl[fb[a->ind].kl[f]] = 1;	
					}						
				}
			}
		}
	}
	//if (verbose) printf("%d ls: ", count);
	//if (verbose) Ispisi( ls);
	return ls;
}

atom *listasusjeda( atom *igrac, atom *protivnik)
{
	//namjestib( igrac, protivnik);
	atom *ls = NULL;
	int s, flag[107], count = 0; 
	for ( s = 1; s < 107 ; s++) flag[s]=0;
	while (igrac != NULL)
	{
		 
		if ((b[ b[igrac->ind].s[0] ].igrac != 1) && b[ b[igrac->ind].s[0] ].protivnik != 1 && (b[igrac->ind].s[0] != 0 ) && (!flag[b[igrac->ind].s[0]])) 
		{
						count++;
			dodaj( &ls, b[igrac->ind].s[0]);
			flag[ b[igrac->ind].s[0] ]++;
		}
		if ((b[ b[igrac->ind].s[1] ].igrac != 1) && b[ b[igrac->ind].s[1] ].protivnik != 1 && (b[igrac->ind].s[1] != 0 ) && (!flag[b[igrac->ind].s[1]])) 
		{
						count++;
			dodaj( &ls, b[igrac->ind].s[1]);
			flag[ b[igrac->ind].s[1] ]++;
		}			
		if ((b[ b[igrac->ind].s[2] ].igrac != 1) && b[ b[igrac->ind].s[2] ].protivnik != 1 && (b[igrac->ind].s[2] != 0 ) && (!flag[b[igrac->ind].s[2]])) 
		{
						count++;
			dodaj( &ls, b[igrac->ind].s[2]);
			flag[ b[igrac->ind].s[2] ]++;
		}
		if ((b[ b[igrac->ind].s[3] ].igrac != 1) && b[ b[igrac->ind].s[3] ].protivnik != 1 && (b[igrac->ind].s[3] != 0 ) && (!flag[b[igrac->ind].s[3]])) 
		{
						count++;
			dodaj( &ls, b[igrac->ind].s[3]);
			flag[ b[igrac->ind].s[3] ]++;
		}
		if ((b[ b[igrac->ind].s[4] ].igrac != 1) && b[ b[igrac->ind].s[4] ].protivnik != 1 && (b[igrac->ind].s[4] != 0 ) && (!flag[b[igrac->ind].s[4]])) 
		{
							count++;
		dodaj( &ls, b[igrac->ind].s[4]);
			flag[ b[igrac->ind].s[4] ]++;
		}
		if ((b[ b[igrac->ind].s[5] ].igrac != 1) && b[ b[igrac->ind].s[5] ].protivnik != 1 && (b[igrac->ind].s[5] != 0 ) && (!flag[b[igrac->ind].s[5]])) 
		{
						count++;
			dodaj( &ls, b[igrac->ind].s[5]);
			flag[ b[igrac->ind].s[5] ]++;
		}
		igrac = igrac->next; 
	}
	while (protivnik != NULL)
	{
		 
		if ((b[ b[protivnik->ind].s[0] ].igrac != 1) && (b[ b[protivnik->ind].s[0] ].protivnik != 1) && (b[protivnik->ind].s[0] != 0) && (!flag[b[protivnik->ind].s[0]])) 
		{
						count++;
			dodaj( &ls, b[protivnik->ind].s[0]);
			flag[ b[protivnik->ind].s[0] ]++;
		}
		if ((b[ b[protivnik->ind].s[1] ].igrac != 1) && (b[ b[protivnik->ind].s[1] ].protivnik != 1) && (b[protivnik->ind].s[1] != 0) && (!flag[b[protivnik->ind].s[1]])) 
		{
						count++;
			dodaj( &ls, b[protivnik->ind].s[1]);
			flag[ b[protivnik->ind].s[1] ]++;
		}
		if ((b[ b[protivnik->ind].s[2] ].igrac != 1) && (b[ b[protivnik->ind].s[2] ].protivnik != 1) && (b[protivnik->ind].s[2] != 0) && (!flag[b[protivnik->ind].s[2]])) 
		{	
						count++;
			dodaj( &ls, b[protivnik->ind].s[2]);
			flag[ b[protivnik->ind].s[2] ]++;
		}
		if ((b[ b[protivnik->ind].s[3] ].igrac != 1) && (b[ b[protivnik->ind].s[3] ].protivnik != 1) && (b[protivnik->ind].s[3] != 0) && (!flag[b[protivnik->ind].s[3]])) 
		{
						count++;
			dodaj( &ls, b[protivnik->ind].s[3]);
			flag[ b[protivnik->ind].s[3] ]++;
		}
		if ((b[ b[protivnik->ind].s[4] ].igrac != 1) && (b[ b[protivnik->ind].s[4] ].protivnik != 1) && (b[protivnik->ind].s[4] != 0) && (!flag[b[protivnik->ind].s[4]])) 
		{
						count++;
			dodaj( &ls, b[protivnik->ind].s[4]);
			flag[ b[protivnik->ind].s[4] ]++;
		}
		if ((b[ b[protivnik->ind].s[5] ].igrac != 1) && (b[ b[protivnik->ind].s[5] ].protivnik != 1) && (b[protivnik->ind].s[5] != 0) && (!flag[b[protivnik->ind].s[5]])) 
		{	
						count++;
			dodaj( &ls, b[protivnik->ind].s[5]);
			flag[ b[protivnik->ind].s[5] ]++;
		}
		protivnik = protivnik->next;  
	}
	//printf("sus %d ls\n",count);
	return ls;
}

void namjestib( atom *igrac, atom *protivnik)
{
	int i;
	for ( i = 1; i < 107; i++ ) 
	{
		b[i].igrac = 0;
		b[i].protivnik = 0;
	}
	while ( igrac != NULL )
	{
		b[igrac->ind].igrac = 1;
		igrac = igrac->next;
	}
	while ( protivnik != NULL )
	{
		b[protivnik->ind].protivnik = 1;
		protivnik = protivnik->next;
	}
}

node *parent( node *arg )
{
	if ( arg->parent != NULL )	return arg->parent;
	else arg;
}


node *nadjichild( node *arg, int potez )
{
	node *p = arg->firstchild;
	while ( p != NULL )
	{
		if ( p->potez == potez )	return p;
		p = p->sibling;
	}
	return NULL;
}

void obrisinode( node *arg ) //briše SAMOSTALNI node i svu djecu, jer ne pazi da li je dio postojece liste 
{	
	if ( arg == NULL ) return; 
	node *t = arg->firstchild;
	node *p = NULL;
	while ( t != NULL )
	{
		p = t;
		t = t->sibling;
		obrisinode(p);
	}
	free( arg );
	nbrfree++;	
}

/*void obrisinode2(node **arg) //briše SAMOSTALNI node i svu djecu, jer ne pazi da li je dio postojece liste 
{	
	node *t=(*arg)->firstchild;
	node *p=NULL;
	while (t!=NULL)
	{
		p=t;
		t=t->sibling;
		obrisinode2(&p);
	}
	free(*arg);
	brfree++;	
}*/

node *izbacinode( node **parent, int potez ) //izbacuje ali NE briše node i nj. djecu;
{
	node *p = NULL;
	node *t = (*parent)->firstchild;
	while (t != NULL)
	{
		if ( t->potez == potez ) 
		{
			if (p != NULL) p->sibling = t->sibling;
			else (*parent)->firstchild = t->sibling;
			t->sibling = NULL;
			t->parent = NULL;
			return t;
		}
		p = t;
		t = t->sibling;
	}
	return t;
}

void ispisidjecu( node *arg )
{
	if (arg != NULL) if ( arg->parent != NULL)	printf("roditelj %d\n", arg->parent->potez);
	else	printf("nema roditelja\n");	else printf("ne postoji\n");	
	if ( arg != NULL	&&	arg->firstchild != NULL )
	{ 
		node *p;
		p = arg->firstchild;
		printf("pot:%d djeca:\n", arg->potez);
		while ( p != NULL)
		{
			printf("%d -> %d\n", p->potez, p->ocjena);
			p = p->sibling;
		}
		//printf("\n");
	}
	else printf("nema djece\n");
}

void ispisipotez( node *arg )
{
	printf("potez: %d alfa %d beta %d ocjena %d odigr. %d\n", arg->potez, arg->alfa, arg->beta, arg->ocjena, arg->odigrao);
}

node *novinode( node **parent, int potez )
{
	nbrmalloc++;
	if ( *parent == NULL ) 
		{	//printf("nn:korijen\n");
			return calloc( 1, sizeof(node) ); 
		}
	node *novi = malloc(sizeof(node));
	novi->potez = potez;
	novi->parent = *parent;
	novi->firstchild = NULL;
	novi->odigrao = (*parent)->odigrao + 1;
	novi->sibling = (*parent)->firstchild;
	novi->ocjena = (*parent)->odigrao%2 ? -intmax : +intmax;
	(*parent)->firstchild = novi;
	return novi;
}

void ispisipoziciju( pozicija board )
{
	fprintf(stderr, "/\n");
	fprintf(stderr, "/\n");
	fprintf(stderr, "igrac: ");
	Ispisi( board.igrac );
	skupina *s = board.igracskupine;
	int i=0,j;
	fprintf(stderr, "br. vrhova: %d[%d %d %d %d %d]\n",
		board.ivrh[0], board.ivrh[1], board.ivrh[2], board.ivrh[3], board.ivrh[4], board.ivrh[5]);
	while (s != NULL)
	{
		i++;
		atom *p = s->nizkamen;
		fprintf(stderr, "val %d brk. %d, brstr. %d[%d %d %d %d %d] mstr[%d %d %d %d], brvrh. %d: ", 
			s->value, s->brojkamenja, s->brstr, s->str[0], s->str[1], s->str[2], s->str[3], s->str[4],
			 s->mstr[0], s->mstr[1], s->mstr[2], s->mstr[3], s->brvrh);
		while (p != NULL)
		{
			fprintf(stderr, "%d[%d %d %d %d %d]", p->ind, ud[p->ind][0], ud[p->ind][1], ud[p->ind][2], ud[p->ind][3], ud[p->ind][4]);
			//fprintf(stderr, "%d ", p->ind);
			p = p->next;
		}
			klaster *k = s->forsirani;
	fprintf(stderr, "||");
	while ( k != NULL)
	{
		atom *p = k->grupa;
		fprintf(stderr, "|");
		while ( p != NULL)
		{
			fprintf(stderr, " %d", p->ind);
			p = p->next;
		}
		k = k->next;		
	}	
		s = s->next;
		fprintf(stderr, "\n");

	}
	fprintf(stderr, "\n");

	fprintf(stderr, "protivnik: ");
	Ispisi( board.protivnik );
	s = board.protivnikskupine;
	i = 0;
	fprintf(stderr, "br. vrhova: %d[%d %d %d %d %d]\n",
		board.pvrh[0], board.pvrh[1],board.pvrh[2], board.pvrh[3], board.pvrh[4], board.pvrh[5]);
	while (s != NULL)
	{
		i++;
		atom *p = s->nizkamen;
		//fprintf(stderr, "brk. %d, brstr. %d[%d %d %d %d %d], brvrh. %d: ", 
			//s->brojkamenja, s->brstr, s->str[0], s->str[1], s->str[2], s->str[3], s->str[4], s->brvrh);
		fprintf(stderr, "val %d brk. %d, brstr. %d[%d %d %d %d %d] mstr[%d %d %d %d], brvrh. %d: ", 
			s->value, s->brojkamenja, s->brstr, s->str[0], s->str[1], s->str[2], s->str[3], s->str[4],
			 s->mstr[0], s->mstr[1], s->mstr[2], s->mstr[3], s->brvrh);
		while (p != NULL)
		{
			//fprintf(stderr, "%d[%d %d %d %d %d]", p->ind, ud[p->ind][0], ud[p->ind][1], ud[p->ind][2], ud[p->ind][3], ud[p->ind][4]);
			fprintf(stderr, "%d ", p->ind);
			p = p->next;
		}
	fprintf(stderr, "||");
	klaster *k = s->forsirani;
	while ( k != NULL)
	{
		atom *p = k->grupa;
		fprintf(stderr, "|");
		while ( p != NULL)
		{
			fprintf(stderr, " %d", p->ind);
			p = p->next;
		}
		k = k->next;		
	}	
		fprintf(stderr, "\n");
		s = s->next;
	}
	fprintf(stderr, "\n");
	fprintf(stderr, "ocjena : %d\n", board.ocjena);
	fprintf(stderr, "pi : %d\n", pi);
}

void pregledajskupine( skupina *popis, int *lanac, int vrh[6])
{	
	int brkamen, brstr, max = 0;
	int i;
	atom *p;
	//klaster *k;
	for ( i = 0; i < 7; i++) vrh[i] = 0;

	while (popis != NULL)
	{	
		brkamen = 0;
		brstr = 0;
		p = popis->nizkamen;
		while (p != NULL)
		{	
			brkamen++;
			switch ( b[p->ind].boja )
			{
			case 0: break;
			case 6: popis->str[0]++; break;
			case 7: popis->str[1]++; break;	
			case 8: popis->str[2]++; break;
			case 9: popis->str[3]++; break;
			case 10: popis->str[4]++; break;
			case 1: popis->str[0]++; popis->str[4]++; break;
			case 2: popis->str[0]++; popis->str[1]++; break;
			case 3: popis->str[1]++; popis->str[2]++; break;
			case 4: popis->str[2]++; popis->str[3]++; break;
			case 5: popis->str[3]++; popis->str[4]++; break;
				
			}
			p = p->next;
		}
		/*k = popis->forsirani;
		while (k != NULL)
		{	
			switch ( b[k->grupa->ind].boja )
			{
			case 0: break;
			case 6: popis->str[0]++; break;
			case 7: popis->str[1]++; break;	
			case 8: popis->str[2]++; break;
			case 9: popis->str[3]++; break;
			case 10: popis->str[4]++; break;
			case 1: popis->str[0]++; popis->str[4]++; break;
			case 2: popis->str[0]++; popis->str[1]++; break;
			case 3: popis->str[1]++; popis->str[2]++; break;
			case 4: popis->str[2]++; popis->str[3]++; break;
			case 5: popis->str[3]++; popis->str[4]++; break;
				
			}
			k = k->next;
		}*/
		if (popis->str[0])	brstr++;
		if (popis->str[1])	brstr++;
		if (popis->str[2])	brstr++;
		if (popis->str[3])	brstr++;
		if (popis->str[4])	brstr++;
		popis->brojkamenja = brkamen;
		popis->brstr = brstr;
		if (max < brkamen)	max = brkamen;
		//popis->brstr = *brstr;
				//printf("popis broj kamenja %d brskupina %d\n", popis->brojkamenja, brkamen);
		if ((popis->str[4]&&popis->str[0])&&(popis->str[1]||popis->str[2]||popis->str[3])) popis->vrh[1]++;
		//if fact(popis->str[0])	

		if ((popis->str[0]&&popis->str[1])&&(popis->str[2]||popis->str[3]||popis->str[4])) popis->vrh[2]++;
		if ((popis->str[1]&&popis->str[2])&&(popis->str[0]||popis->str[3]||popis->str[4])) popis->vrh[3]++;
		if ((popis->str[2]&&popis->str[3])&&(popis->str[0]||popis->str[1]||popis->str[4])) popis->vrh[4]++;
		if ((popis->str[3]&&popis->str[4])&&(popis->str[0]||popis->str[1]||popis->str[2])) popis->vrh[5]++;
		if (popis->vrh[1]) vrh[1]++;
		if (popis->vrh[2]) vrh[2]++;
		if (popis->vrh[3]) vrh[3]++;
		if (popis->vrh[4]) vrh[4]++;
		if (popis->vrh[5]) vrh[5]++;
		for (i=1;i<6;i++) if (popis->vrh[i]) popis->brvrh++;
		
		
		popis=popis->next;
	}
	
	for (i=1;i<6;i++) if (vrh[i]) vrh[0]++;
	*lanac = max;
}

skupina *skupineigrac( pozicija **bazen )
{
	atom *p, kamen;
	(*bazen)->buff = kopirajniz( (*bazen)->igrac );
	p = (*bazen)->buff;
	while (p != NULL)
	{
		ubaciskupinu( &(*bazen)->igracskupine, novaskupina() );
		ubaci( &(*bazen)->igracskupine->nizkamen, izbaci( &(*bazen)->buff, p->ind) );
		(*bazen)->brskupinaigrac++;
		skupinasusjed( &(*bazen)->buff, &(*bazen)->igracskupine->nizkamen, p->ind, &(*bazen)->igracskupine->forsirani );
		p = (*bazen)->buff;
	}
}

skupina *skupineprotivnik( pozicija **bazen )
{
	atom *p, kamen;
	(*bazen)->buff = kopirajniz( (*bazen)->protivnik );
	p = (*bazen)->buff;
	while (p != NULL)
	{
		ubaciskupinu( &(*bazen)->protivnikskupine, novaskupina() );
		ubaci( &(*bazen)->protivnikskupine->nizkamen, izbaci(&(*bazen)->buff, p->ind) );
		(*bazen)->brskupinaprotivnik++;
		skupinasusjedp( &(*bazen)->buff, &(*bazen)->protivnikskupine->nizkamen, p->ind, &(*bazen)->protivnikskupine->forsirani );
		p = (*bazen)->buff;
	}
}

void skupinasusjed( atom **buff, atom **niz, int kamen, klaster **forsirani)
{
	atom *z;
	z = *buff;
	int nk, sk;
	while (z != NULL)
	{
	sk = susjed( z->ind, kamen, forsirani);
	if ( sk < 0)
	{	
		nk = z->ind;
		ubaci( niz, izbaci(buff,nk) );
		skupinasusjed( buff, niz, nk, forsirani);
		z = *buff;
	}
	else if ( sk > 0)
	{
		nk = z->ind;
		ubaci( niz, izbaci(buff,nk) );
		ubaci( niz, izbaci(buff,sk) );
		skupinasusjed( buff, niz, nk, forsirani);
		skupinasusjed( buff, niz, sk, forsirani);
		z = *buff;
	}
	else z = z->next;
	}
}

void skupinasusjedp( atom **buff, atom **niz, int kamen, klaster **forsirani)
{
	atom *z,*t;
	z = *buff;
	int nk, sk;
	while (z != NULL)
	{
	sk = susjedp( z->ind, kamen, forsirani);
	if ( sk < 0)
	{	
		nk = z->ind;
		ubaci( niz, izbaci(buff,nk) );
		skupinasusjedp( buff, niz, nk, forsirani);
		z = *buff;
	}
	else if ( sk > 0)
	{
		nk = z->ind;
	
		ubaci( niz, izbaci(buff,nk));
		ubaci( niz, izbaci(buff,sk) );
		skupinasusjedp( buff, niz, nk, forsirani);
		skupinasusjedp( buff, niz, sk, forsirani);
		z = *buff;
	}
	else z = z->next;
	}
}

pozicija *novapozicija( atom *igracset, atom *protivnikset )
{	
	pozicija *novi = malloc( sizeof(pozicija) );
	novi->igrac = kopirajniz( igracset );
	novi->protivnik = kopirajniz( protivnikset );
	novi->ocjena = 0;
	skupineigrac( &novi );
	skupineprotivnik( &novi );
	pregledajskupine( novi->igracskupine, &(novi->lanacigrac), novi->ivrh);
	pregledajskupine( novi->protivnikskupine, &(novi->lanacprotivnik), novi->pvrh);
	//novi->igracskupine=NULL;
	//novi->protivnikskupine=NULL;
	return novi;
}

void ubaciskupinu( skupina **pocetak, skupina *arg )
{
	arg->next = *pocetak;	
	*pocetak = arg;
}

skupina *novaskupina( )
{
	skupina *novi = calloc( 1, sizeof(skupina) );
	return novi;
}

atom *izbaci( atom **pocetak, int ind )
//izbacuje iz skupine ali ne briše iz memorije!!
{
	atom *temp = *pocetak;
	atom *prev = NULL;
	//atom * ret;
		//if (ind == 53) printf("iz\n");
	while (temp != NULL)
	{
		if (temp->ind == ind) 
		{
			if (prev != NULL) prev->next = temp->next;
			else *pocetak = temp->next;
			temp->next = NULL;
			return temp;
		}
		prev = temp;
		temp = temp->next;
	}
	return NULL;
}

void ubaci( atom **pocetak, atom *arg )
{
	if (arg == NULL) return;
	arg->next = *pocetak;	
	*pocetak = arg;
}

void dodaj( atom **pocetak, int ind )
{

	atom *novi = *pocetak;
	*pocetak = noviatom(ind);
	(*pocetak)->next = novi;
}

atom *kopirajniz( atom *stari )
{
	if (stari != NULL) 
	{
		atom *novi = noviatom( stari->ind );
		stari = stari->next;
		while (stari != NULL)
		{
			dodaj( &novi, stari->ind );
			stari = stari->next;	
		}
		return novi;
	}
	else return NULL;
	
}

int *vratisusjede( int ind, int printaj )
{	
	if ( printaj ) printf("%d  susjedi: %d %d %d %d %d %d\n",
	b[ind].ind, b[ind].s[0], b[ind].s[1], b[ind].s[2], b[ind].s[3], b[ind].s[4], b[ind].s[5] );
	return b[ind].s;
}

void zamijeni( atom **b, atom **c)
{
	Ispisi(*b);
	Ispisi(*c);
	printf( "bind %d", (*b)->ind);
	dodaj( b, (*c)->ind);
	atom *ba =izbaci( b, (*b)->ind);
	obrisi( ba);
	printf( "b:");
	Ispisi(*b);
	obrisi( izbaci( c, -1));
	printf( "poslije");
	Ispisi(*b);
	printf( "c:");
	Ispisi(*c);
	/*UniznaKraj( cpocetak, ckraj, ((*bkraj)->ind) );
	VanizNiza( bpocetak, bkraj, (*bkraj)->ind );
	VanizNiza( cpocetak, ckraj, -1 );*/
}

void Zamijeni( atom **bpocetak, atom **bkraj, atom ** cpocetak, atom ** ckraj )
//premiješta zadnji atom bijelog u crni skup 
{
	UniznaKraj( cpocetak, ckraj, ((*bkraj)->ind) );
	VanizNiza( bpocetak, bkraj, (*bkraj)->ind );
	VanizNiza( cpocetak, ckraj, -1 );
}

void UniznaKraj( atom **pocetak, atom **kraj, int ind )
{
	atom *novi = noviatom( ind );
	if ( *pocetak != NULL ) 
	{
		(*kraj)->next = novi;
		*kraj = novi;
	} 
	else 
	{
		*pocetak = novi;
		*kraj = novi;
	}
}

atom  *VanizNiza( atom ** pocetak, atom  **kraj, int ind )
{	
	atom *temp = *pocetak;
	atom *prev = NULL;
	atom *ret;
	while (temp != NULL)
	{
		if (temp->ind == ind) 
		{
			if (prev != NULL)	prev->next = temp->next;
			else *pocetak = temp->next;
			if (temp->next == NULL)	*kraj = prev;
			ret = temp->next;
			free(temp);
			return ret;
		}
		prev = temp;
		temp = temp->next;
	}
	return NULL;
}


atom *noviatom( int ind )
{	
	//dodati provjeru malloc
	amalloc++;
	//printf("amall %d\n", ind);	
	atom *novi = malloc( sizeof(atom) );
	novi->ind = ind;
	novi->next = NULL;
	return novi;
}

klaster dodajklaster( klaster **pocetak, atom *niz, int count, int tip)
{
	klaster *novi = malloc( sizeof( klaster ));
	novi->grupa = niz;
	novi->count = count;
	novi->tip = tip;
	novi->next = *pocetak;
	*pocetak = novi;	
}

/*void obrisiklaster( klaster **pocetak, int ind)
{
	int c = 0;
	klaster *temp = *pocetak;
	klaster *prev = NULL;
	//atom * ret;
	while (temp != NULL)
	{
		if ( !(temp->tip) && ((temp->grupa->ind == ind) || (temp->grupa->next->ind == ind)) 
		{
			if (prev != NULL) prev->next = temp->next;
			else *pocetak = temp->next;
			temp->next = NULL;
		}
		prev = temp;
		temp = temp->next;
	}
}*/

int obrisiklasterniz( klaster **arg)
{
	klaster *p;
	int c = 0;
	while (*arg != NULL) 
	{
		p = *arg;
		*arg = (*arg)->next;
		//printf("afree %d\n", p->ind);	
		obrisiniz( &(p->grupa));
		free( p);
		c++;
	}
	return c;
}

int susjed( int ind1, int ind2, klaster **cloud)
{
	int f, c;
	if (b[ind1].s[0] == ind2) return -1;
	else if (b[ind1].s[1] == ind2) return -1;
	else if (b[ind1].s[2] == ind2) return -1;
	else if (b[ind1].s[3] == ind2) return -1;
	else if (b[ind1].s[4] == ind2) return -1;
	else if (b[ind1].s[5] == ind2) return -1;
	for ( f = 0; f < 6; f++) 
	{
	if 	(fb[ind1].s[f] == ind2) 
	{
	if 	(!((b[fb[ind1].kl[f]].igrac) || (b[fb[ind1].kl[f+6]].igrac) 
		|| (b[fb[ind1].kl[f]].protivnik) || (b[fb[ind1].kl[f+6]].protivnik) ||
	(b[fb[ind1].s[(f+1)%6]].igrac) || (b[fb[ind1].s[(f+5)%6]].igrac)))
	{
		//dodaj novi klaster 
		//printf("s2 %d %d fb[ind1].kl[f] %d fb[ind1].kl[f+6] %d\n", ind1 ,ind2,fb[ind1].kl[f],fb[ind1].kl[f+6]);
		atom *niz = NULL;
		dodaj( &niz, fb[ind1].kl[f]);
		dodaj( &niz, fb[ind1].kl[f+6]);
		dodajklaster( cloud, niz, 2, 0);
		return -1;
	}
	else if ((b[fb[ind1].s[(f+5)%6]].igrac) && (!((b[fb[ind1].s[(f+1)%6]].igrac) || (b[fb[ ind1].kl[f]].igrac))) &&
		(((b[fb[ ind1].kl[f]].protivnik) && ((b[fb[ ind1].bl[f]].igrac)||(b[fb[ ind1].kl[(f+5)%6]].igrac)||(b[fb[ ind1].kl[f+6]].igrac))) 		|| !((b[fb[ ind1].bl[f]].protivnik)||(b[fb[ ind1].kl[(f+5)%6]].protivnik)||(b[fb[ ind1].kl[f+6]].protivnik)||(b[fb[ ind1].kl[f]].protivnik))))
		/*|| (b[fb[ ind1].kl[f]].protivnik) || (b[fb[ ind1].kl[(f+5)%6]].igrac)))*/
	{
		atom *niz = NULL;
		/*printf("* %d %d\n", ind1, fb[ ind1].kl[f+6] );
printf("s %d %d fb[ind1].s[f] %d b[fb[ind1].kl[f]].igrac %d b[fb[ind1].kl[f+6]].igrac %d b[fb[ind1].kl[f]].protivnik %d b[fb[ind1].kl[f+6]].protivnik %d\n"
,ind1,ind2,fb[ind1].s[f],b[fb[ind1].kl[f]].igrac,b[fb[ind1].kl[f+6]].igrac,b[fb[ind1].kl[f]].protivnik,b[fb[ind1].kl[(f+1)%6]].protivnik);*/

		c = 0;
		if (!((b[ fb[ ind1].kl[(f+5)%6]].protivnik)||(b[ fb[ ind1].kl[(f+5)%6]].igrac))) {dodaj( &niz, fb[ ind1].kl[(f+5)%6]);	c++;}
		if (!((b[ fb[ind1].kl[f+6]].protivnik)||(b[ fb[ind1].kl[f+6]].igrac))) {dodaj( &niz, fb[ind1].kl[f+6]);	c++;}
		if (!((b[ fb[ ind1].bl[f]].igrac)||(b[ fb[ ind1].bl[f]].protivnik))) {dodaj( &niz, fb[ ind1].bl[f]);	c++;}
		if (!((b[ fb[ind1].kl[f]].protivnik)||(b[ fb[ind1].kl[f]].igrac))) {dodaj( &niz, fb[ind1].kl[f]);	c++;}

		if (c>1)
		{
		dodajklaster( cloud, niz, c, 2);
		return fb[ind1].s[(f+5)%6];
		}
		else obrisiniz( &niz);
		
	}
	else if ((b[fb[ind1].s[(f+1)%6]].igrac) && (!((b[fb[ind1].s[(f+5)%6]].igrac) || (b[fb[ ind1].kl[f+6]].igrac))) &&
		(((b[fb[ ind1].kl[f+6]].protivnik)) && ((b[fb[ ind1].bl[f+6]].igrac)||(b[fb[ ind1].kl[f]].igrac)||(b[fb[ind1].kl[(f+2)%6]].igrac))
	|| !((b[fb[ ind1].bl[f+6]].protivnik)||(b[fb[ ind1].kl[f]].protivnik)||(b[fb[ind1].kl[(f+2)%6]].protivnik)||(b[fb[ ind1].kl[f+6]].protivnik))))
		/*|| (b[fb[ ind1].kl[f+6]].protivnik) || (b[fb[ ind1].kl[(f+1)%6]].igrac)))*/		
	{
		atom *niz = NULL;
		/*printf("/ %d %d ret %d\n", ind1, fb[ ind1].kl[f+6],fb[ind1].s[(f+1)%6] );
printf("s %d %d fb[ind1].s[f] %d b[fb[ind1].kl[f+6]].igrac %d b[fb[ind1].kl[f+6]].igrac %d b[fb[ind1].kl[f]].protivnik %d b[fb[ind1].kl[f+6]].protivnik %d\n"
,ind1,ind2,fb[ind1].s[f],b[fb[ind1].kl[f+6]].igrac,b[fb[ind1].bl[f+6]].protivnik,b[fb[ind1].kl[f]].protivnik,b[fb[ind1].kl[(f+2)%6]].protivnik);*/

		c = 0;
		if (!((b[ fb[ ind1].kl[(f+2)%6]].protivnik)||(b[ fb[ ind1].kl[(f+2)%6]].igrac))) {dodaj( &niz, fb[ ind1].kl[(f+2)%6]);	c++;}
		if (!((b[ fb[ind1].kl[f]].protivnik)||(b[ fb[ind1].kl[f]].igrac))) {dodaj( &niz, fb[ind1].kl[f]);	c++;}
		if (!((b[ fb[ ind1].bl[f+6]].protivnik)||(b[ fb[ ind1].bl[f+6]].igrac))) {dodaj( &niz, fb[ ind1].bl[f+6]);	c++;}
		if (!((b[ fb[ind1].kl[f+6]].igrac)||(b[ fb[ind1].kl[f+6]].protivnik))) {dodaj( &niz, fb[ind1].kl[f+6]);	c++;}

		if (c>1)
		{
		dodajklaster( cloud, niz, c, 2);
		return fb[ind1].s[(f+1)%6];
		}
		else obrisiniz( &niz);
	}
}

	}
	return 0;
}

int susjedp( int ind1, int ind2, klaster **cloud)
{
	int f, c;
	if (b[ind1].s[0] == ind2) return -1;
	else if (b[ind1].s[1] == ind2) return -1;
	else if (b[ind1].s[2] == ind2) return -1;
	else if (b[ind1].s[3] == ind2) return -1;
	else if (b[ind1].s[4] == ind2) return -1;
	else if (b[ind1].s[5] == ind2) return -1;
	for ( f = 0; f < 6; f++) {
	if 	(fb[ind1].s[f] == ind2) 
	{
	if 	(!((b[fb[ind1].kl[f]].igrac) || (b[fb[ind1].kl[f+6]].igrac) 
		|| (b[fb[ind1].kl[f]].protivnik) || (b[fb[ind1].kl[f+6]].protivnik) ||
	(b[fb[ind1].s[(f+1)%6]].protivnik) || (b[fb[ind1].s[(f+5)%6]].protivnik)))
	{
		//dodaj novi klaster 
		//printf("s2 %d %d fb[ind1].kl[f] %d fb[ind1].kl[f+6] %d\n", ind1 ,ind2,fb[ind1].kl[f],fb[ind1].kl[f+6]);
		atom *niz = NULL;
		dodaj( &niz, fb[ind1].kl[f]);
		dodaj( &niz, fb[ind1].kl[f+6]);
		dodajklaster( cloud, niz, 2, 0);
		return -1;
	}
	else if ((b[fb[ind1].s[(f+5)%6]].protivnik) && (!((b[fb[ind1].s[(f+1)%6]].protivnik) || (b[fb[ ind1].kl[f]].protivnik))) &&
		(((b[fb[ ind1].kl[f]].igrac) && ((b[fb[ ind1].bl[f]].protivnik)||(b[fb[ ind1].kl[(f+5)%6]].protivnik)||(b[fb[ ind1].kl[f+6]].protivnik))) 			|| !((b[fb[ ind1].bl[f]].igrac)||(b[fb[ ind1].kl[(f+5)%6]].igrac)||(b[fb[ ind1].kl[f+6]].igrac)||(b[fb[ ind1].kl[f]].igrac))))
		/*|| (b[fb[ ind1].kl[f]].protivnik) || (b[fb[ ind1].kl[(f+5)%6]].igrac)))*/
	{
		atom *niz = NULL;
		/*printf("* %d %d ret %d\n", ind1, fb[ ind1].kl[f+6], fb[ind1].s[(f+5)%6] );
printf("s %d %d fb[ind1].s[f] %d b[fb[ind1].kl[f]].igrac %d b[fb[ind1].kl[f+6]].igrac %d b[fb[ind1].kl[f]].protivnik %d b[fb[ind1].kl[f+6]].protivnik %d\n"
,ind1,ind2,fb[ind1].s[f],b[fb[ind1].kl[f]].igrac,b[fb[ind1].kl[f+6]].igrac,b[fb[ind1].kl[f]].protivnik,b[fb[ind1].kl[(f+1)%6]].protivnik);*/

		c = 0;
		if (!((b[ fb[ ind1].kl[(f+5)%6]].protivnik)||(b[ fb[ ind1].kl[(f+5)%6]].igrac))) {dodaj( &niz, fb[ ind1].kl[(f+5)%6]);	c++;}
		if (!((b[ fb[ind1].kl[f+6]].protivnik)||(b[ fb[ind1].kl[f+6]].igrac))) {dodaj( &niz, fb[ind1].kl[f+6]);	c++;}
		if (!((b[ fb[ ind1].bl[f]].igrac)||(b[ fb[ ind1].bl[f]].protivnik))) {dodaj( &niz, fb[ ind1].bl[f]);	c++;}
		if (!((b[ fb[ind1].kl[f]].protivnik)||(b[ fb[ind1].kl[f]].igrac))) {dodaj( &niz, fb[ind1].kl[f]);	c++;}

		if (c>1)
		{
		dodajklaster( cloud, niz, c, 2);
		return fb[ind1].s[(f+5)%6];
		}
		else obrisiniz( &niz);
		
	}
	else if ((b[fb[ind1].s[(f+1)%6]].protivnik) && (!((b[fb[ind1].s[(f+5)%6]].protivnik) || (b[fb[ ind1].kl[f+6]].protivnik))) &&
		(((b[fb[ ind1].kl[f+6]].igrac)) && ((b[fb[ ind1].bl[f+6]].protivnik)||(b[fb[ ind1].kl[f]].protivnik)||(b[fb[ind1].kl[(f+2)%6]].protivnik))
		|| !((b[fb[ ind1].bl[f+6]].igrac)||(b[fb[ ind1].kl[f]].igrac)||(b[fb[ind1].kl[(f+2)%6]].igrac)||(b[fb[ ind1].kl[f+6]].igrac))))
		/*|| (b[fb[ ind1].kl[f+6]].protivnik) || (b[fb[ ind1].kl[(f+1)%6]].igrac)))*/		
	{
		atom *niz = NULL;
		/*printf("/ %d %d ret %d\n", ind1, fb[ ind1].kl[f+6],fb[ind1].s[(f+1)%6] );
printf("s %d %d fb[ind1].s[f] %d b[fb[ind1].kl[f+6]].igrac %d b[fb[ind1].kl[f+6]].igrac %d b[fb[ind1].kl[f]].protivnik %d b[fb[ind1].kl[f+6]].protivnik %d\n"
,ind1,ind2,fb[ind1].s[f],b[fb[ind1].kl[f+6]].igrac,b[fb[ind1].bl[f+6]].protivnik,b[fb[ind1].kl[f]].protivnik,b[fb[ind1].kl[(f+2)%6]].protivnik);*/
		c = 0;
		if (!((b[ fb[ ind1].kl[(f+2)%6]].protivnik)||(b[ fb[ ind1].kl[(f+2)%6]].igrac))) {dodaj( &niz, fb[ ind1].kl[(f+2)%6]);	c++;}
		if (!((b[ fb[ind1].kl[f]].protivnik)||(b[ fb[ind1].kl[f]].igrac))) {dodaj( &niz, fb[ind1].kl[f]);	c++;}
		if (!((b[ fb[ ind1].bl[f+6]].protivnik)||(b[ fb[ ind1].bl[f+6]].igrac))) {dodaj( &niz, fb[ ind1].bl[f+6]);	c++;}
		if (!((b[ fb[ind1].kl[f+6]].igrac)||(b[ fb[ind1].kl[f+6]].protivnik))) {dodaj( &niz, fb[ind1].kl[f+6]);	c++;}

		if (c>1)
		{
		dodajklaster( cloud, niz, c, 2);
		return fb[ind1].s[(f+1)%6];
		}
		else obrisiniz( &niz);
	}
}
	}
	return 0;
}

int provjeriskupine( skupina2 **popis, int brskupina )
{	
	int vrh[] = {0,0,0,0,0,0};
	int brkamen;
	int i;
	atom *p;
	for ( i=0; i<brskupina; i++ )
	{	
		brkamen = 0;
		p = (*popis[i]).pocetak;
		while (p != NULL)
		{	
			brkamen++;
			switch ( b[p->ind].boja )
			{
			case 0: break;
			case 6: (*popis[i]).str1++;	break;
			case 7: (*popis[i]).str2++;	break;	
			case 8: (*popis[i]).str3++;	break;
			case 9: (*popis[i]).str4++;	break;
			case 10: (*popis[i]).str5++;	break;
			case 1: (*popis[i]).str1++;(*popis[i]).str5++;	break;
			case 2: (*popis[i]).str1++;(*popis[i]).str2++;	break;
			case 3: (*popis[i]).str2++;(*popis[i]).str3++;	break;
			case 4: (*popis[i]).str3++;(*popis[i]).str4++;	break;
			case 5: (*popis[i]).str4++;(*popis[i]).str5++;	break;
				
			}
			p = p->next;
		}
		if (((*popis[i]).str5&&(*popis[i]).str1) && ((*popis[i]).str2 || (*popis[i]).str3 || (*popis[i]).str4)) vrh[1]++;
		if (((*popis[i]).str1&&(*popis[i]).str2) && ((*popis[i]).str3 || (*popis[i]).str4 || (*popis[i]).str5)) vrh[2]++;
		if (((*popis[i]).str2&&(*popis[i]).str3) && ((*popis[i]).str1 || (*popis[i]).str4 || (*popis[i]).str5)) vrh[3]++;
		if (((*popis[i]).str3&&(*popis[i]).str4) && ((*popis[i]).str1 || (*popis[i]).str2 || (*popis[i]).str5)) vrh[4]++;
		if (((*popis[i]).str4&&(*popis[i]).str5) && ((*popis[i]).str1 || (*popis[i]).str2 || (*popis[i]).str3)) vrh[5]++;
					
	}
	for ( i=1; i<6; i++ ) if ( vrh[i] ) vrh[0]++;
	return vrh[0];
}

void Ispisi( atom * list )
{
	while (list != NULL) 
	{
	printf("%d ", (*list).ind);
	list = (*list).next;
	} 
	printf("\n");
}

atom *kraj( atom *pocetak )
{
	while (pocetak->next = NULL) pocetak = pocetak->next;
	return pocetak;
}

atom *trazi( atom *pocetak, int ind )
{
	while (pocetak != NULL)
	{
		if (pocetak->ind == ind) return pocetak;
		pocetak = pocetak->next;
	}
	return NULL;
}

void nulltest( atom **a, atom **b )
{
	if (*a == NULL)	printf("t:a je NULL\n");
	else	printf("t:a nije NULL\n");
	if (*b == NULL) printf("t:b je NULL\n");
	else	printf("t:b nije NULL\n");
}

int rdstdin( int *d )
{ //int d;
  char w[100]; 
	if (strcmp(w,"Quit") == 0) return 0;
	else {
		*d = strtol(w,NULL,10);
		return *d;
	}
	//printf("()%d $%s\n",*d,w);
}

void initploca( ploca p )
{
/*int l;
for (l=0;l<dulj;l++)
{
	p[l].ind=l;
	p[l].s[1]= &p[1];
	printf("%d\n",p[l].ind);
}*/

}

/*void crtajpolje(cairo_t *cr, double scale, int x, int y, int ind, double rgb[3], int which, int str)
{
	int i;
	char l[3];
  cairo_set_source_rgb(cr, 0, 0, 0);
  cairo_set_line_width(cr, 1);

  cairo_move_to(cr, bp[ind].s[1][0]*scale + x, bp[ind].s[1][1]*scale + y);
//printf("ind: %d \n", ind); printf("%d %d\n", bp[ind].s[1][0], bp[ind].s[1][1]);
  for (i = 2; i < 7; i++) {  //printf("%d %d\n", bp[ind].s[i][0], bp[ind].s[i][1]);
	if ( bp[ind].s[i][0] != -1 )      cairo_line_to(cr, bp[ind].s[i][0]*scale + x, bp[ind].s[i][1]*scale + y);
  }

  cairo_close_path(cr);
  cairo_stroke_preserve(cr);
  cairo_set_source_rgb(cr, rgb[0], rgb[1], rgb[2]);
//  cairo_set_source_rgb(cr, 0, 0, 0);
  cairo_fill(cr);

  cairo_select_font_face(cr, "Purisa",
      CAIRO_FONT_SLANT_NORMAL,
      CAIRO_FONT_WEIGHT_BOLD);

  cairo_set_font_size(cr, 13*scale);

  cairo_set_source_rgb(cr, 0, 0.6, 0);
  cairo_move_to(cr, bp[ind].s[0][0]*scale + x, bp[ind].s[0][1]*scale + y);
	switch (which)
	{
		case -1: sprintf(l, "%d", ind); break;
		case 0: sprintf(l, "%d", ud[ind][str]); break;
		default: sprintf(l, "%d", up[ind][str]);
	}
	//sprintf(l, "%d", ind);
  cairo_show_text(cr, l);  

}

static gboolean on_draw_event(GtkWidget *widget, cairo_t *cr, gpointer user_data)
{
  do_drawing(cr);
	//gtk_main_quit();

  return FALSE;
}

static void do_drawing(cairo_t *cr)
{ 
	//gint i;
	int i, j, x, y;
	double sc;
	double boja[3]  = { 0.66, 0.66, 0};
	double bijela[3]  = { 0.8, 0.8, 0.8};
	double crna[3]  = { 0.2, 0.2, 0.2};
	double crvena[3]  = { 0.5, 0, 0};
	int fl[dulj];
// crtaj pozicija 
	
	for (j = 0; j < dulj+1; j++) fl[j] = 1;
	sc = 1;	x = -30;	y = 0;
	atom *it = kand;
	while ( it != NULL )
	{
		//printf("k:%d\n", it->ind);
		crtajpolje( cr, sc, x, y, it->ind, crvena, -1, 0);
		fl[it->ind] = 0;
		it = it->next;
	}
	it = igrac;
	while ( it != NULL )
	{
		//printf("%d\n", it->ind);
		crtajpolje( cr, sc, x, y, it->ind, bijela, -1, 0);
		fl[it->ind] = 0;
		it = it->next;
	}
	it = protivnik;
	while ( it != NULL )
	{
		crtajpolje( cr, sc, x, y, it->ind, crna, -1, 0);
		fl[it->ind] = 0;
		it = it->next;
	}

	for (j = 1; j < dulj+1; j++)	if ( fl[j] )	crtajpolje( cr, sc, x, y, j, boja, -1, 0);

//crtaj udaljenost

	for ( i = 0; i < 5; i++)
	{
	sc = 0.66;	x = 430+430*sc*i;	y = 0;
	for (j = 0; j < dulj+1; j++) fl[j] = 1;
	it = kand;
	while ( it != NULL )
	{
		//printf("k:%d\n", it->ind);
		crtajpolje( cr, sc, x, y, it->ind, crvena, 0, i);
		fl[it->ind] = 0;
		it = it->next;
	}
	it = igrac;
	while ( it != NULL )
	{
		//printf("%d\n", it->ind);
		crtajpolje( cr, sc, x, y, it->ind, bijela, 0, i);
		fl[it->ind] = 0;
		it = it->next;
	}
	it = protivnik;
	while ( it != NULL )
	{
		crtajpolje( cr, sc, x, y, it->ind, crna, -1, i);
		fl[it->ind] = 0;
		it = it->next;
	}

	for (j = 1; j < dulj+1; j++)	if ( fl[j] )	crtajpolje( cr, sc, x, y, j, boja, 0, i);
	}
	
	for ( i = 0; i < 5; i++)
	{
	sc = 0.66;	x = 430+430*sc*i;	y = 280;
	for (j = 0; j < dulj+1; j++) fl[j] = 1;
	it = kand;
	while ( it != NULL )
	{
		//printf("k:%d\n", it->ind);
		crtajpolje( cr, sc, x, y, it->ind, crvena, 1, i);
		fl[it->ind] = 0;
		it = it->next;
	}
	it = igrac;
	while ( it != NULL )
	{
		//printf("%d\n", it->ind);
		crtajpolje( cr, sc, x, y, it->ind, bijela, -1, i);
		fl[it->ind] = 0;
		it = it->next;
	}
	it = protivnik;
	while ( it != NULL )
	{
		crtajpolje( cr, sc, x, y, it->ind, crna, 1, i);
		fl[it->ind] = 0;
		it = it->next;
	}

	for (j = 1; j < dulj+1; j++)	if ( fl[j] )	crtajpolje( cr, sc, x, y, j, boja, 1, i);

	}

}*/
//---------------------------------------main--------------------------------------


int main ( int argc, char *argv[] )
{

#define duljstr 999
int l=0;
int rd=1;
int i;
int br, brpotez = 0;
int potez=1;
int brvrhova;
char st[duljstr];
int depth=2;
int analiza = 0; 
		/*GtkWidget *window;
		GtkWidget *darea;*/

test = novapozicija( igrac, protivnik);

//čitanje pozicije iz html-a
if ( argc > 2) depth = strtol( argv[2], NULL, 10);
{
	if (depth < 0) 
	{
		potez = 0;
		depth = abs( depth);
	}
	if (argc > 1) 
	{	
	verbose = 1;

	FILE *game = fopen( argv[1], "r" );
	if (game == NULL) printf("nije otvoren file\n");
	else while ( fgets(st,duljstr,game) != NULL )
	{	
		char *ss = strstr( st, "var MOVES = new Array" );
		int numchar;
		if (ss != NULL)
		{	
			ss+=sizeof("var MOVES = new Array");
			while ( (sscanf(ss,"%i%n",&br,&numchar)) && (brpotez < depth))
			{
			brpotez++;
			ss += numchar + 1;
			if ( potez ) 
			{
				dodaj( &igrac, br);
				//UniznaKraj( &bijeli, &bijelikraj,br );
				potez = 0;
			}
			else
			{
				dodaj( &protivnik, br);
				//UniznaKraj( &crni, &crnikraj, br );
				if (br == -1) Zamijeni( &igrac, &igrac, &protivnik, &protivnik);
				potez = 1;
			}
			}
		}
	}	
	setpozicija( &test, igrac, protivnik);
	ispisipoziciju( *test);
// GTK DRAW



//	test = novapozicija( igrac, protivnik);

//start=time(NULL);
//IGRAJ();
//end=time(NULL);
//printf("time: %d\n",(start-end));
//printf(" alfa: %d \n",alfabeta( &root, depth, -100, +100, igrac, protivnik, &test, 1, &choice));
//najpotez = nadjipotez( root);
//printf("IGRAM: %d\n", najpotez->potez);

//ispisidjecu( root );
//printf("root potez: %d\n",root->potez);
//printf("IGRAM: %d\n", choice );
//Ispisi(korjenniz);
//printf("pi: %d\n",pi);
//printf("size of node %d size of node2 %d\n", sizeof(node), sizeof(node2));
//printf("brmalloc %d uk %i Mb\n", brmalloc, sizeof(node)*brmalloc/(1024*1024));

	}
}

while (1)
{
  char w[100]; 
	
	//zovi do_draw
	/*if (verbose)
	{
		gtk_init(&argc, &argv);
		window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
		darea = gtk_drawing_area_new();
		gtk_container_add(GTK_CONTAINER(window), darea);
		g_signal_connect(G_OBJECT(darea), "draw", 
		G_CALLBACK(on_draw_event), NULL);  
		g_signal_connect(window, "destroy",
		G_CALLBACK(gtk_main_quit), NULL);
	
		//gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);
		gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_NONE);
		gtk_window_set_default_size(GTK_WINDOW(window), 1980, 420); 
		gtk_window_set_title(GTK_WINDOW(window), "PolyY");
	
		
		gtk_widget_show_all(window);
		gtk_main();

	}	*/

	scanf("%s",w);

	if (strstr(w,"Start") != NULL) 
	{	
		//test = novapozicija( igrac, protivnik);
		if (igrac != NULL)	IGRAJ( 0);
		else
		{
			prvi = 1;
			dodaj( &igrac, pocetnipotez);
			moves++;
			printf("%d\n", pocetnipotez);
			fflush(stdout);
		}
	}
	else
	if ( strcmp(w,"-1") == 0 )	
	{	
		dodaj ( &protivnik, -1);
		Zamijeni( &igrac, &igrac, &protivnik, &protivnik);
		IGRAJ( -1);
		
		//		write stderr
		
	} 
	else
	if ( strcmp(w,"Quit") == 0 )	
	{	
 		fprintf(stderr, "uktime %f pozicija %d pozicija po sekundi %f\n", potroseno_vrijeme, uk_p, uk_p/potroseno_vrijeme); 		
		//		write stderr
		break;
	}


	/*if (strstr(w,"izb")!=NULL) 
	{
	printf("?:");
	scanf("%d",&br);
	VanizNiza(&bijeli,&bijelikraj,br);
	Ispisi(bijeli);
	}
	else if (strstr(w,"napoc")!=NULL)
	{
	printf("?:");
	scanf("%d",&br);
	UniznaPocetak(&bijeli,&bijelikraj,br);
	Ispisi(bijeli);
	}
	else if (strstr(w,"nakraj")!=NULL)
	{
	printf("?:");
	if (bijeli!=NULL) printf("pocetak %d, kraj %d\n",bijeli->ind,bijelikraj->ind);
	scanf("%d",&br);
	UniznaKraj(&bijeli,&bijelikraj,br);
	Ispisi(bijeli);
	}*/
		
	else if ( strstr(w,"kand") != NULL )
	{
		setpozicija( &test, igrac, protivnik);
		gk = generirajkandidate( test);
		obrisiniz( &kand);
		kand = a_l_k( gk);
		ispisikandidate( gk);
		//Ispisi( kand);
	}
	else if ( strstr(w,"sus") != NULL )
	{
		kand = listasusjeda( igrac, protivnik);
		//Ispisi( kand);
	}
	else if ( strstr(w,"gen") != NULL )
	{
		setpozicija( &test, igrac, protivnik);
		//kand = test->potezi;
		kand = generirajpoteze( test);
		//Ispisi( kand);
	}
	else if ( strstr(w,"analiza") != NULL )
	{
		if ( !analiza)	obrisi( izbaci( &igrac, choice));
		analiza =  ( !analiza);
		setpozicija( &test, igrac, protivnik);
		ispisipoziciju(*test);
		gk = generirajkandidate( test);
		obrisiniz( &kand);
		kand = a_l_k( gk);
		ispisikandidate( gk);
	}
	else if ( strstr(w,"do.dj") != NULL )
	{
		printf("?: ");
		scanf("%d", &br);
		novinode( &root, br );
		ispisidjecu( root );
	}
	else if	( strstr(w,"udji") != NULL )
	{
		printf("?: ");
		scanf("%d", &br);
		root = nadjichild( root, br );
		if ( analiza )
		{
		root->odigrao%2 ? dodaj( &igrac, br) : dodaj( &protivnik, br);
		setpozicija( &test, igrac, protivnik);
		kand = generirajpoteze( test);
		ispisipoziciju( *test);
		}
		ispisipotez( root );
		root->firstchild = sortlist( root, !(root->odigrao%2));
		ispisidjecu( root );
	
	}
	else if	( strstr(w,"izadji") != NULL )
	{
		if ( analiza )
		{
		root->odigrao%2 ? obrisi( izbaci( &igrac, root->potez)) : obrisi( izbaci(  &protivnik, root->potez));
		setpozicija( &test, igrac, protivnik);
		kand = generirajpoteze( test);
		ispisipoziciju( *test);
		}
		root = parent( root );
		ispisipotez( root );
		root->firstchild = sortlist( root, !(root->odigrao%2));
		ispisidjecu( root );
	}
	else if	( strstr(w,"obrisi") != NULL )
	{
		printf("?: ");
		scanf("%d", &br);
		node *del=izbacinode(&root,br);
		obrisinode(del);
		obrisinode( izbacinode(&root, br) );
		ispisidjecu( root );
	}
	else if	( strstr(w,"point") != NULL )
	{
		printf("?: ");
		scanf("%d", &br);
		node *z = nadjichild( root, br );
		if ( z != NULL )
		{
			printf("za potez: %d alfa %d beta %d ocjena %d odigrao %d\n",
				 z->potez, z->alfa, z->beta, z->ocjena, z->odigrao);
			if ( z->parent == NULL )	printf ("parent je NULL\n");
			else printf("par: %d\n", (z->parent)->potez);
			if ( z->firstchild == NULL )	printf ("firstchild je NULL\n");
			else	printf("fc: %d\n", (z->firstchild)->potez);
			if ( z->sibling == NULL )	printf ("sibling je NULL\n");
			else	printf("sibling: %d\n", (z->sibling)->potez);
			
		}
		else printf("z je null\n");
		//printf("par: %d fc: %d sibl: %d\n", z->parent->potez, z->firstchild->potez, z->sibling->potez);
	}
	else if	( strstr(w,"proot") != NULL )
	{
		node *z = root;
		if ( z != NULL )
		{
			printf("trenut.node: %d alfa %d beta %d ocjena %d odigrao %d\n",
				z->potez,z->alfa,z->beta, z->ocjena ,z->odigrao);
			if ( z->parent == NULL)		printf ("parent je NULL\n");
			else	printf("par: %d\n", z->parent->potez);
			if ( z->firstchild == NULL )	printf ("firstchild je NULL\n");
			else	printf("fc: %d\n", z->firstchild->potez);
			if ( z->sibling == NULL )	printf ("sibling je NULL\n");
			else	printf("sibling: %d\n", z->sibling->potez);
			
		}
		else printf("z je null\n");
		//printf("par: %d fc: %d sibl: %d\n", z->parent->potez, z->firstchild->potez, z->sibling->potez);
	}
	else if	( strstr(w,"pot") != NULL )
	{
		ispisipotez( root );
		root->firstchild = sortlist( root, !(root->odigrao%2));
		ispisidjecu( root );
	}
	else if	( strstr(w,"bezs") != NULL )
	{
		ispisipotez( root );
		ispisidjecu( root );
	}
	else if	( strstr(w,"sortmin") != NULL )
	{
		ispisipotez( root );
		root->firstchild = sortlist( root, 0);
		ispisidjecu( root );
	}
	else if	( strstr(w,"bacibombu") !=NULL )
	{
		obrisinode( root );
		printf("br malloc: %d", nbrmalloc);
		printf("br free %d", nbrfree);
	}
		else 
	{	
		//if ( protivnik == NULL ) 
		// 		crni na potezu
		rd= strtol( w, NULL, 10);
		dodaj( &protivnik, rd);

		IGRAJ( rd);
		//	ispisipoziciju( test);
	}

}
return 0;
}

